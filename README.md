# FiniteStateMachine

# PROJECT REQUIREMENTS

# CIRCUIT SCHEMATIC
<img src="https://i.ibb.co/GR4jYhZ/schematic.jpg" alt="schematic" border="0">

* The SSD1306 display has 4 lines which need to be connected (Vcc and GND being two of them).
* The I<sup>2</sup>C SDA (serial data) line is connected to the analog pin 4 on the Teensy microcontroller.
* The I<sup>2</sup>C SCL (serial clock) line is connected to analog pin 5.
* __Note:__ Both of these lines require a pull-up resistor attached to them (to +Vcc, due to the open-drain MOSFET interface of I<sup>2</sup>C, which pulls the voltage of the line down to 0V when the gate is activated). These are internally connected / included the SSD1306 IC, hence were not included on the schematic.

<img src="http://rheingoldheavy.com/wp-content/uploads/2015/01/I2C_Pull_Up_Example.png">

* A potentiometer is connected to analog pin 0 (as an input). The variable resistance provides a voltage between 0 and +3.3V on the line, which will be used to control the horizontal position of the car (as a mapped value).

* Two buttons are connected to digital 


# STATE MACHINE DESIGN
<img src="https://i.ibb.co/5ncZTbp/statemachine.jpg" alt="statemachine" border="0">

This is a Moore state machine design, as the state machine action depends only on the active state.   
Typically, this is just displaying the current state's screen / animation.  
* The __START__ and __LOAD__ states are progressed by pressing the start button.  
* The __RUNNING__ state toggles with the __PAUSED__ state by pressing the pause button.  
* The game engine runs in one state (see above right), and the pause state is a "pause" text overlay over the current game frame / loop. 
* The __RUNNING__ state transitions to either the __SUCCESS__ or __GAMEOVER__ state, depending on the outcome of the game.
* Pressing start in either of these states transitions back to the __START__ state.  

The corresponding state actions are as follows:
* `displayStartScreen()` - the screen the player is first met with. Introduces the game.  
* `displayLoadScreen()` - prompts the player to calibrate / reset the potentiometer to reset the starting position of the car. This is required as the knob is a physical mechanism (superceeding any software reset done).  
* `runGame()` - run the game engine, until the player wins or loses.  
* `displayPaused()` - hold the game's current frame, until the player re-presses pause.  
* `displayWinScreen()` - reward the player with a victory animation.  
* `displayLoseScreen()` - consolidate the player with a defeat screen.  

Transitions between states depend on these 'events':
* `Start_Pressed` - set when the 'start' button press triggers an external interrupt (negative edge on the line detected), and in the interrupt service routine called.  
* `Pause_Pressed` - similarly as above.  
* `Collision` - set when the player's car collides with the road edges or with any oncoming car in the game.  
* `Win` - set when the player successfully passes the required number of cars (in this specific instance).  

Note: As the start and pause button 'pressed flag' latches on when the corresponding button is pressed, these need to be reset when transitioning to a state checking for these button presses (to further transition). This prevents improper state transitioning - for example, if the start button was pressed during the game running state, the result (if not reset) would be immediately restarting the game when it was won or lost. The gameover or game won screen would not be visible to the player.

# PHYSICAL CIRCUIT
<img src="https://i.ibb.co/nPXnSB2/breadboardcircuit.jpg" alt="breadboardcircuit" border="0">


# CODE IMPLEMENTATION

* EXPLAIN RUNGAME
* EXPLAIN STATEMACHINE

# VERIFICATION
* video of states

# DISCUSSION
* improvements

# IMAGES AND REFERENCES
<img src="https://i.ibb.co/V2H6Txn/lcdassistant.jpg" alt="lcdassistant" border="0"> 

[LCD Assistant](http://en.radzio.dxp.pl/bitmap_converter/) was used to convert monochrome bitmaps to an array of bytes, corresponding to bits (each pixel) that needed to be turned on in order to reproduce the image on the display.  

Below are the images used:  

<img src="https://i.ibb.co/YXXHpGh/mazda-323f-1993-2.jpg" alt="mazda-323f-1993-2" border="0"><img src="https://i.ibb.co/k1RwF41/mazda-323f-1993-tiny.jpg" alt="mazda-323f-1993-tiny" border="0">  
https://getoutlines.com/blueprints/3143/1998-mazda-323f-lantis-f-hatchback-blueprints

<img src="https://i.ibb.co/chX98p3/render-97.png" alt="render-97" border="0"><img src="https://i.ibb.co/y45htKp/dxracer.png" alt="dxracer" border="0"><img src="https://i.ibb.co/bv4p8rv/dxracer-RIP.png" alt="dxracer-RIP" border="0">  
https://gamebanana.com/sprays/21984

<img src="https://i.ibb.co/7nwqyK3/tropy-award.jpg" alt="tropy-award" border="0"><img src="https://i.ibb.co/BKYy9FG/tropy-award-pixel.jpg" alt="tropy-award-pixel" border="0">
https://bornzilla.eventsmart.com/events/meet-greet-soulzepi/tropy-award/ 



# APPENDIX 

SSD1306 datasheet--

__SSD1306 Example Code__ 
This sample code used as reference for drawing to the OLED screen can be found [here]  (https://github.com/adafruit/Adafruit_SSD1306/blob/master/examples/ssd1306_128x64_i2c/ssd1306_128x64_i2c.ino).  
This was for the 128x64 pixel, I2C protocol specific display type.

A modified version of the 'snowflake example' (testanimate) within this sample program was used as part of the game's victory screen. 

__Source Code__
 
```javascript
/**************************************************************************
 This is an example for our Monochrome OLEDs based on SSD1306 drivers

 Pick one up today in the adafruit shop!
 ------> http://www.adafruit.com/category/63_98

 This example is for a 128x32 pixel display using I2C to communicate
 3 pins are required to interface (two I2C and one reset).

 Adafruit invests time and resources providing this open
 source code, please support Adafruit and open-source
 hardware by purchasing products from Adafruit!

 Written by Limor Fried/Ladyada for Adafruit Industries,
 with contributions from the open source community.
 BSD license, check license.txt for more information
 All text above, and the splash screen below must be
 included in any redistribution.
 **************************************************************************/
#include <Arduino.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET     4 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

//for snowflakes animation example
#define NUMFLAKES     20
#define LOGO_HEIGHT   16
#define LOGO_WIDTH    16
#define XPOS   0 // 'icons' array index (snowflake x,y,dy position variables)
#define YPOS   1
#define DELTAY 2
const unsigned char PROGMEM logo_bmp[] = { 
  B00000000, B11000000,
  B00000001, B11000000,
  B00000001, B11000000,
  B00000011, B11100000,
  B11110011, B11100000,
  B11111110, B11111000,
  B01111110, B11111111,
  B00110011, B10011111,
  B00011111, B11111100,
  B00001101, B01110000,
  B00011011, B10100000,
  B00111111, B11100000,
  B00111111, B11110000,
  B01111100, B11110000,
  B01110000, B01110000,
  B00000000, B00110000 
};
bool snowflakeinit = false; //initialize snowflake positions once per gameover screen

//function prototypes
void ISR_Start();
void ISR_Pause();
void testanimate(const uint8_t *bitmap, uint8_t w, uint8_t h);

//game screen bitmaps
const uint8_t car_img[] PROGMEM = {
  0x0F, 0xF0, 0x10, 0x08, 0xEF, 0xF7, 0x28, 0x14, 0x40, 0x02, 0x44, 0x22, 0x7F, 0xFE, 0x60, 0x06
}; //16x8 pixels
const uint8_t startscreen_img[] PROGMEM = {
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x3F, 0xE3, 0xE1, 0xDF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x3F, 0xF3, 0xF3, 0xDF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1C, 0x78, 0xF7, 0xCC, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1C, 0x38, 0x7F, 0x0C, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1C, 0x38, 0x3E, 0x0C, 0xE3, 0xE0, 0x7C, 0x78, 0xFE, 0x1F, 0xCF, 0x87, 0xC3, 0xE0, 0x00,
	0x00, 0x1C, 0x38, 0x1C, 0x0F, 0xC3, 0xF0, 0xFC, 0xFE, 0xFE, 0x1F, 0xDF, 0xCF, 0xE7, 0xF0, 0x00,
	0x00, 0x1C, 0x38, 0x1E, 0x0F, 0x80, 0x31, 0xCD, 0xCE, 0x76, 0x1F, 0xB9, 0xDC, 0xEF, 0x70, 0x00,
	0x00, 0x1C, 0x18, 0x3E, 0x0D, 0xC3, 0xF1, 0x8D, 0xFE, 0x70, 0x18, 0x39, 0xDC, 0xEE, 0x70, 0x00,
	0x00, 0x1C, 0x38, 0x77, 0x0C, 0xE7, 0xF1, 0x81, 0xFC, 0x70, 0x1F, 0xB9, 0xDC, 0xEE, 0x70, 0x00,
	0x00, 0x1C, 0x70, 0xE7, 0x8C, 0x76, 0x31, 0xC1, 0xC0, 0x70, 0x1F, 0xBB, 0xDC, 0xEE, 0x70, 0x00,
	0x00, 0x3F, 0xE3, 0xE3, 0xDE, 0x7B, 0xF9, 0xFD, 0xFE, 0xF8, 0x01, 0xDF, 0x9F, 0xCF, 0xE0, 0x00,
	0x00, 0x3F, 0xC3, 0xE3, 0xDE, 0x7B, 0xF8, 0xFC, 0x7E, 0xF8, 0x01, 0xC0, 0x0F, 0x87, 0xC0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xDF, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xDF, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xE0, 0x01, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xC0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x70, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x04, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1D, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x14, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
	0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00,
	0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00,
	0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x80, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x79, 0xF8, 0x00, 0x11, 0x00, 0x09, 0x14, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x73, 0xF8, 0x07, 0xC8, 0xFF, 0xF0, 0x1F, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x07, 0xE3, 0xFF, 0x08, 0xFF, 0xC0, 0x00, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x06, 0x00, 0x00, 0x13, 0x9F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x80, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
	0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xE1, 0xC0, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x19, 0x80, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00
}; //128x64 pixels
const uint8_t gameoverscreen_img[] PROGMEM ={
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x40, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x9F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x9F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x1F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x10, 0x00, 0x03, 0x3F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x10, 0x00, 0x03, 0x3F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF
};
const uint8_t gameoverscreen_imgsteam[] PROGMEM = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFE, 0x7F, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x3F, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x9F, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xDF, 0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xBF, 0xFF, 0xDF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x3F, 0xFF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x7F, 0xFF, 0x9F, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFE, 0x7F, 0xFF, 0xBF, 0xFB, 0xFF, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFC, 0xFF, 0xDF, 0xBF, 0xFB, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xF9, 0xFF, 0xFC, 0x00, 0x1F, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xF3, 0xFF, 0x81, 0x00, 0x00, 0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0x7F, 0xF7, 0xFF, 0xC3, 0x00, 0x04, 0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xEF, 0xFF, 0x46, 0x00, 0x04, 0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xEF, 0xFF, 0x04, 0x00, 0x04, 0x00, 0x67, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xEF, 0xFF, 0x04, 0x00, 0x04, 0x00, 0x77, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xEF, 0xF8, 0x04, 0x00, 0x06, 0x00, 0x17, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xEF, 0xE8, 0x04, 0x00, 0x03, 0x00, 0x13, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xE8, 0x04, 0x00, 0x01, 0x00, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xC8, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF9, 0xF0, 0x0C, 0x00, 0x06, 0x00, 0x01, 0x00, 0x04, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFD, 0xF0, 0x04, 0x00, 0x02, 0x00, 0x03, 0x00, 0x05, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFD, 0x00, 0x02, 0x00, 0x03, 0x00, 0x02, 0x00, 0x05, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF2, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06, 0x00, 0x05, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF3, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x0D, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE1, 0xE0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE1, 0xE0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0xF0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0xF0, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x9E, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x9E, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF1, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF7, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x1F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x06, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x10, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x18, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x08, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x08, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x04, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x04, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x10, 0x00, 0x03, 0x3F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x10, 0x00, 0x03, 0x3F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF
};
const uint8_t winscreen_img[] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0x80, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x70, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFF, 0xF3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x07, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0xC0, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x01, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x80, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x01, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x80, 0x1D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x80, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDC, 0x01, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xC0, 0x39, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0x01, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x60, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x03, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x30, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x07, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x0F, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0C, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x1E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x7C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0xC0, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x03, 0xE0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x78, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x1F, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1E, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x7E, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x07, 0x8F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xF8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xE0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0xFF, 0xCD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x78, 0xFF, 0xFF, 0x0E, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xF0, 0x3F, 0xFE, 0x07, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF8, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xF6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xE0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7B, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xE8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7B, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xF8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x02, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00
};

//game difficulty parameters
//**note: move delay <30, feels like significant increase in speed
const uint8_t NUMCARS = 8 ; //number of cars to win the game
const uint8_t DELAYSTEP = 2; //number of cars before delay decrements
const uint16_t CAR_LAUNCHDELAYMAX_MS = 2000; //starting / reset delay values
const uint8_t CAR_MOVEDELAYMAX_MS = 100;
const uint8_t CARLAUNCH_DECR = 250; //decrement amounts per iteration
const uint8_t CARMOVE_DECR = 25;

//global variables for game
const uint8_t ROAD_W = 88; //(bottom of) road width
const uint8_t ROAD_H = 30; //2d height of road
const uint8_t ROAD_DEL = 30; //pixel convergence of road lines (parallax)
const uint8_t ROAD_CEN = display.width()/2; //centre point of road
const uint8_t ROAD_L_EDGE = ROAD_CEN - ROAD_W /2; //bottom left point of road
const uint8_t ROAD_R_EDGE = ROAD_CEN + ROAD_W /2;
const uint8_t ROAD_Y = display.height() - ROAD_H; //y pixel position of road line = 34

const uint8_t CAR_H = 8; //car dimensions
const uint8_t CAR_W = 16;
const uint8_t CAR_Y = 55; //car is fixed vertically, can only move horizontally

enum sideOfRoad {left_side, down_centre, right_side, both_sides, left_cen, right_cen}; //sides of the road for oncoming cars
enum gameReturn {none, collision, win}; //game return variable (for state transition from 'running')
enum State {S_Start, S_Load, S_Running, S_Paused, S_Winning, S_Gameover}; //FSM states
State current_state = S_Start; //state machine initialization
uint32_t gameStartTime_ms = 0; //time 'game running' started
uint32_t gameTime_ms = 0; //time 'game running' elapsed
float potAvg = 0; float potOld = 0; //averaging potentiometer value to mitigate noise
bool canLoad = false; //can progress past loading screen flag

//global variables for buttons
uint8_t startButtonPin = 11; //digital Teensy pin
uint8_t pauseButtonPin = 12;
const uint8_t DEBOUNCE_DELAY_MS = 200;
volatile bool start_pressed = 0; //flags for 'button has been pressed'
volatile bool pause_pressed = 0;

//CAR FUNCTIONS
/* return a random 'sideOfRoad' (for the approaching cars) */
sideOfRoad getRandomSide(){
  sideOfRoad values[6] = {left_side, down_centre, right_side, both_sides, left_cen, right_cen};
  uint8_t r = (uint8_t)random(0,6);
  return values[r]; 
}

/* draw road edges and median strip */
void drawRoad(uint8_t med){
  display.drawLine(ROAD_L_EDGE+ROAD_DEL, ROAD_Y, ROAD_L_EDGE, ROAD_Y+ROAD_H, WHITE); 
  display.drawLine(ROAD_R_EDGE-ROAD_DEL, ROAD_Y, ROAD_R_EDGE, ROAD_Y+ROAD_H, WHITE);
  
  //alternate median strip lines (depending on 'medianState')
  //for loop used as initially much smaller spacing (the i increment)
  if (med==0){
    for (uint8_t i = 0; i<ROAD_H; i=i+20){
    display.drawFastVLine(ROAD_CEN, ROAD_Y+i, 5, WHITE);}
  }
  else if(med==1){
    for (uint8_t i = 5; i<ROAD_H; i=i+20){
    display.drawFastVLine(ROAD_CEN, ROAD_Y+i, 5, WHITE);}
  }
  else if(med==2){
    for (uint8_t i = 10; i<ROAD_H; i=i+20){
    display.drawFastVLine(ROAD_CEN, ROAD_Y+i, 5, WHITE);}
  }
  else{
    for (uint8_t i = 15; i<ROAD_H; i=i+20){
    display.drawFastVLine(ROAD_CEN, ROAD_Y+i, 5, WHITE);}
  }
}

/* draws player's car*/
void drawCar(int cen){ 
  //note: need to offset car centre by car width/height, as draws from top left corner
  //display.drawRect(cen-(CAR_W/2), CAR_Y, CAR_W, CAR_H, WHITE);
  display.drawBitmap(cen-(CAR_W/2), CAR_Y, car_img, CAR_W, CAR_H, WHITE);
}

/* detects collision between player car and road edges */
bool collisionDetectionRoad(uint8_t car_cen){
  if ((car_cen - CAR_W/2)< ROAD_L_EDGE){ //if player car's left side < road left edge
    return true;
  }
  else if ((car_cen + CAR_W/2)>ROAD_R_EDGE){ //if player car's right side > road right edge
    return true;
  }
  else {
    return false;
  }
}

/* detect collision between player's car and approaching cars within collision proximity */
bool collisionDetectionCar (uint8_t car_cen, sideOfRoad side){
  switch(side){
    case left_side: //collision if player car's left side < left car's right
      if((car_cen - CAR_W/2) < (ROAD_CEN - ROAD_W/4 + CAR_W/2)){return true;}
      else {return false;}

    case right_side: //collision if players car's right side > right car's left
      if((car_cen + CAR_W/2) > (ROAD_CEN + ROAD_W/4 - CAR_W/2)){return true;}
      else {return false;}

    case both_sides: //check player within central area (right edge of left, left edge of right car)
      if((car_cen - CAR_W/2) < (ROAD_CEN - ROAD_W/4 + CAR_W/2)){return true;}
      else if((car_cen + CAR_W/2) > (ROAD_CEN + ROAD_W/4 - CAR_W/2)){return true;}
      else {return false;}

    case down_centre: //check player car clears centre car from either road side
      if((car_cen < ROAD_CEN) and ((car_cen + CAR_W/2) > (ROAD_CEN - CAR_W/2))){return true;}
      if((car_cen > ROAD_CEN) and ((car_cen - CAR_W/2) < (ROAD_CEN + CAR_W/2))){return true;}
      else {return false;}
    
    case left_cen: //player car's left edge must be right of centre car's right
      if((car_cen - CAR_W/2) < ROAD_CEN + CAR_W/2) {return true;}
      else {return false;}

    case right_cen: //player car's right edge must be left of centre car's left
      if ((car_cen + CAR_W/2) > ROAD_CEN - CAR_W/2) {return true;}
      else {return false;}
  }
  return false;
}

/* draw approaching cars */
void carApproaching(int car_prox, sideOfRoad side){
  //car gets bigger during vertical travel (x/30), x=0..30
  float car_scaling = (float)car_prox / (float)ROAD_H; 
  float car_scaling_size = min(car_scaling*10, 1.0);

  // int car_scaling_pos_right = map(car_prox,0,ROAD_H,ROAD_CEN + 0.5*ROAD_W - 0.75*ROAD_DEL, ROAD_CEN + 0.25*ROAD_W);
  // int car_scaling_pos_right = ROAD_CEN + 7 + car_prox/2 [i.e +7 to +22] <- 1/4line of road
  int car_scaling_pos_right = map(car_prox,0,ROAD_H,ROAD_CEN+10, ROAD_CEN+25); //hard coded to visually be centred
  int car_scaling_pos_left = map(car_prox,0,ROAD_H,ROAD_CEN-10, ROAD_CEN-25);

  switch (side){
    case left_side: //car moving down left
      //display.drawRect(car_scaling_pos_left-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_left-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    case down_centre: //car moving down centre
      //display.drawRect(ROAD_CEN-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(ROAD_CEN-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    case right_side: //car moving down right
      //display.drawRect(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    case both_sides:
      //display.drawRect(car_scaling_pos_left-(CAR_W/2*car_scaling_size),ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      //display.drawRect(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_left-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE); 
      break;

    case left_cen:
      //display.drawRect(car_scaling_pos_left-(CAR_W/2*car_scaling_size),ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      //display.drawRect(ROAD_CEN-(CAR_W/2*car_scaling_size),ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_left-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(ROAD_CEN-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    case right_cen:
      //display.drawRect(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      //display.drawRect(ROAD_CEN-(CAR_W/2*car_scaling_size),ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(ROAD_CEN-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    //case: car changing lanes? -> fixed final position to check for collision
    //note: size scaling changes bitmap frame size, instead of actually changing proportions
    //may need custom images for 'appearing' sequence
  }  
}

//DISPLAY FUNCTIONS
/* draw start screen with alternating "start" text */
void displayStartScreen(bool startscreenstate){
  display.clearDisplay();
  if (startscreenstate){ //startscreenstate is a flag that gets toggled in the state machine
    display.drawBitmap(0,0,startscreen_img,display.width(),display.height(),WHITE);
    display.setTextSize(1);                 
    display.setCursor(32,30);
    display.setTextColor(WHITE);             
    display.println(F("press start"));
  }else{
    display.drawBitmap(0,0,startscreen_img,display.width(),display.height(),WHITE);
  }
  display.display();
}
/* draw load screen - prompting player to calibrate potentiometer */
bool displayLoadScreen(){
  display.clearDisplay();
  display.setTextSize(1);                 
  display.setCursor(0,0);             
  display.println(F("Please calibrate steering wheel"));
  uint32_t potValue = analogRead(A0); //read potentiometer value
  potAvg = 0.1*potValue + 0.9*potOld; //update current average value (for noise mitigation)
  potOld = potAvg;
  uint32_t posValue = map(potAvg,1,1023,ROAD_L_EDGE, ROAD_R_EDGE); //map to car centre position
  display.drawFastVLine(posValue,32,5,WHITE);
  display.drawFastVLine(ROAD_L_EDGE,32,5,WHITE);
  display.drawFastVLine(ROAD_R_EDGE,32,5,WHITE);
  display.display();
  //return to 'canLoad' whether the game should be able to start (won't result in instant crash)
  if(collisionDetectionRoad(posValue)){
    return false;
  }else{
    return true;
  }
}
/* display "pause" text on screen */
void displayPause(){
  display.setTextSize(2);                  
  display.setCursor(28,10);             
  display.println(F("PAUSED"));
  display.display();
}
/* display 'you crashed' text to indicate a collision has occured */
void displayBOOM(){
  display.setTextSize(2);                  
  display.setCursor(0,0);             
  display.println(F("*^KABOOMv#"));
  display.display();
}
/* draw gameover screen and re-start prompt */
void displaygameover(bool endscreenstate){
  display.clearDisplay();
  if(endscreenstate){
    display.drawBitmap(0,0,gameoverscreen_img, display.width(),display.height(), WHITE);
  }else{
    display.drawBitmap(0,0,gameoverscreen_imgsteam, display.width(), display.height(), WHITE);
  }
  display.setTextSize(1);                  
  display.setCursor(10,2);
  display.setTextColor(BLACK);          
  display.println(F("Press start to try"));
  display.setCursor(90,12);
  display.println(F("again."));
  display.display();
}
/* draw game win screen */
void displayWOO(){
  display.clearDisplay();
  display.drawBitmap(0,0,winscreen_img,display.width(),display.height(),WHITE);
  display.setTextSize(1);                    
  display.setCursor(44,10);  
  display.setTextColor(BLACK);           
  display.println(F("WINNING"));
  testanimate(logo_bmp, LOGO_WIDTH, LOGO_HEIGHT);
  display.display();
}
/* display in game text indicating game progression */
void displayCarsRemaining(uint8_t num, uint8_t count){
  display.setTextSize(1);               
  display.setCursor(0,0);             
  display.print(F("Cars remaining: "));
  display.print(num - count);
}

/* THE GAME runs until it returns 'win' or 'collision' */
gameReturn runGame(){
  //note: one shared variable for car position 'carProx' = only one 'car' on screen at a time
  //object oriented implementation (each car has its own 'distance away') better if multiple concurrent cars are needed

  static uint16_t carLaunchDelay_ms = CAR_LAUNCHDELAYMAX_MS; //<- minimum time before next car launches (decreases)
  static uint8_t carMoveDelay_ms = CAR_MOVEDELAYMAX_MS; //<-- delay affects speed of car (decreases)

  static uint8_t car_prox = 0; //increases as cars move toward screen 0->30 (road_h)
  static uint32_t lastCar_ms = 0; //the last time a car was launched
  static uint32_t lastCarMove_ms = 0; //the last time the car on screen moved
  static bool launchCar = false; //flag for if a car is on the road
  static sideOfRoad nextCarSide = getRandomSide();
  static uint8_t car_count = 0; //numbers of sets of cars passed

  static uint8_t medianState = 0; //to alternate median strip
  static uint32_t lastMedianChange_ms = 0;

  //reset game variables for re-start of game
  if (gameTime_ms == 0){
    car_prox = 0; lastCar_ms = 0; launchCar = false; lastCarMove_ms = 0;
    car_count = 0; carLaunchDelay_ms = CAR_LAUNCHDELAYMAX_MS; carMoveDelay_ms = CAR_MOVEDELAYMAX_MS;
    lastMedianChange_ms = 0; medianState = 0;
  }
  //calculate position of user's car
  uint32_t potValue = analogRead(A0); //read potentiometer value
  potAvg = 0.1*potValue + 0.9*potOld; //implement rolling average
  potOld = potAvg;
  uint32_t posValue = map(potAvg,1,1023,ROAD_L_EDGE, ROAD_R_EDGE); //map to car centre position
  
  display.clearDisplay();

  //draw the road lines and the player's car
  drawRoad(medianState);
  drawCar(posValue);

  //determine if median strip needs to be alternated (every 250ms)
  if ((gameTime_ms - lastMedianChange_ms) > 250){
    lastMedianChange_ms = gameTime_ms;
    if(medianState==0){medianState=1;}
    else if(medianState==1){medianState=2;}
    else if(medianState==2){medianState=3;}
    else{medianState=0;}
  }
  
  //launch a car depending if carLaunchDelay_ms threshold reached
  //when carLaunchDelay_ms < 'time to move across screen' -> immediately launches once the previous car is 'done'
  if ((gameTime_ms - lastCar_ms) > carLaunchDelay_ms){
    lastCar_ms = gameTime_ms;
    launchCar = true;
  }
  //draw the approaching cars, moving downwards depending on carMoveDelay_ms time
  if (launchCar){
      carApproaching(car_prox,nextCarSide); //car approaching of distance away, and position designator
      if (millis() - lastCarMove_ms > carMoveDelay_ms){ //carMoveDelay determines speed of car approach 50 -> 0.
        lastCarMove_ms = millis();
        car_prox = car_prox + 1; //car proximity 0 (top of road) to road height (bottom of screen)
      } 
      //when car reaches end of road...    
      if(car_prox > ROAD_H){
        car_prox = 0; //reset car distance variable
        launchCar = false; //car no longer on road
        car_count++; //increment cars passed
        nextCarSide = getRandomSide(); //for next car

        //win if count > threshold. 
        //alternatively, game time could correspond to distance travelled.
        if (car_count == NUMCARS){ return win;}

        //decrease car delays evey delayStep # cars
        if ((car_count > 0) and (car_count % DELAYSTEP) == 0){
          carLaunchDelay_ms = max(carLaunchDelay_ms - CARLAUNCH_DECR,0);
          carMoveDelay_ms = max(carMoveDelay_ms - CARMOVE_DECR,0);
        }
      }
  }
    
  //check for collisions with road & approaching cars (allowing for "clipping" if passed)
  if (collisionDetectionRoad(posValue)){return collision;}
  if((car_prox > ROAD_H-10) and (car_prox < ROAD_H-5) and (collisionDetectionCar(posValue,nextCarSide))){
    return collision;
  }
  //display game progress text
  displayCarsRemaining(NUMCARS, car_count);
  display.display(); //write buffer contents to screen
  gameTime_ms = millis() - gameStartTime_ms; //update game timer
  return none; //'none' return = game continues
}

//MAIN- STATE MACHINE
void setup() {
  Serial.begin(9600);
  Wire.setClock(3400000);

  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3C for 128x32
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }
  //initializing button digital pins with interrupts attached
  pinMode(startButtonPin, INPUT_PULLUP);
  pinMode(pauseButtonPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(startButtonPin), ISR_Start, FALLING);
  attachInterrupt(digitalPinToInterrupt(pauseButtonPin), ISR_Pause, FALLING);

  display.setTextColor(WHITE);  //initial color
  display.display(); //initial buffer = Adafruit splash screen
  display.clearDisplay(); // Clear the buffer
  while (millis()<1000){} //delay to show Adafruit screen
}

void loop() {
  //'time when this screen occured' variables
  static uint32_t startscreentime_ms = 0;  static uint32_t gameovertime_ms = 0;  static uint32_t endscreentime_ms = 0;
  static bool startscreenstate = 0;  static bool endscreenstate = 0;
  switch (current_state){

    case S_Start:
      //could add: startup animation
      //action: start screen alternates displaying "press start" text, every 1s
      displayStartScreen(startscreenstate);
      if ((millis() - startscreentime_ms) > 1000){
        startscreentime_ms = millis();
        startscreenstate = !startscreenstate;
      }
      //transition checks - 'start' proceeds to next screen
      if (start_pressed){
        current_state = S_Load;
        start_pressed = 0; //reset on transition - as next screen checks for this
      }
      break;

    case S_Load:
      //load screen to calibrate steering wheel (potentiometer)
      //displayLoadScreen() returns false if would result in crash (with road edge) on game start
      //proceed if 'start' and no collision would occur
      canLoad = displayLoadScreen();
      if (start_pressed and canLoad){
        current_state = S_Running;
        gameStartTime_ms = millis(); //time when start button was pressed
        gameTime_ms = 0; //reset game time
        start_pressed = 0;
        pause_pressed = 0; //in case it was latched (which resulted in pausing the load screen)
      } else{
        start_pressed = 0;
      }
      break;

    case S_Running:
      //could have "startofGame()" = countdown + driving past chequered start line
      //run game until win or gameover
      if (pause_pressed){
        current_state = S_Paused; //pauses game
        pause_pressed = 0;
      }else{ //moves out of 'game running' state in collision / win events
          gameReturn g = runGame();
          if (g == collision){
            current_state = S_Gameover;
            start_pressed = 0;
            gameovertime_ms = millis();
          }
          else if(g == win){
            current_state = S_Winning;
            start_pressed = 0;
            }
      }
      break;

    case S_Paused:
      //display "pause" text, keeping current frame on screen
      displayPause();
      if (pause_pressed){
        current_state = S_Running;
        pause_pressed = 0;
      }
      break;

    case S_Winning:
      //alternating win screen
      displayWOO();
      if(start_pressed){
        display.clearDisplay();
        current_state = S_Start;
        start_pressed = 0;
        startscreenstate = 0; endscreenstate = 0; //for screen display consistency
        snowflakeinit = 0; //^
      }
      break;

    case S_Gameover:
      //display "boom" text if crash
      //alternating gameover screen
      if ((millis() - gameovertime_ms) < 1000){
        displayBOOM();
      }else{
        displaygameover(endscreenstate);
      }
      if ((millis() - endscreentime_ms) > 1000){
        endscreentime_ms = millis();
        endscreenstate = !endscreenstate;
      }
      if(start_pressed){
        display.clearDisplay();
        current_state = S_Start;
        start_pressed = 0;
        startscreenstate = 0; endscreenstate = 0;
      }
      break;
  }
}

void ISR_Start(){
  //debounce delay - ignore all negative edges for a period of time (200ms)
  //after the first, actual press, has been detected
  static uint32_t laststartpress_ms = 0;
  if ((millis() - laststartpress_ms) > DEBOUNCE_DELAY_MS){
    laststartpress_ms = millis();
    start_pressed = 1; //set flag indicating the button has been pressed
  }
}
void ISR_Pause(){
  static uint32_t lastpausepress_ms = 0;
  if (millis() - lastpausepress_ms > DEBOUNCE_DELAY_MS){
    lastpausepress_ms = millis();
    pause_pressed = 1;
  }
}
/*** COMMENTS ***********/
//128x64 pixels -> 30..98, 
//potValue rolling average?

//car = bit map
//collision with road state
//collision with approaching car
// queue cars using timers

//how to draw curved road?
//track / display time, metres left, fps

//exten: joystick: degree of acceleration, braking, steering
// speed control is level of agency on top of steering / handling.
//add more difficult courses (tight corners) where reckless acceleration is punished

//consideration of variable screen sizes -> distances relative to edge, proportional to total dimension

//draw snowflakes - modified
void testanimate(const uint8_t *bitmap, uint8_t w, uint8_t h) {
  static int8_t f, icons[NUMFLAKES][3];
  // Initialize 'snowflake' positions
  if(!snowflakeinit){
    for(f=0; f< NUMFLAKES; f++) {
      icons[f][XPOS]   = random(1 - LOGO_WIDTH, display.width());
      icons[f][YPOS]   = -LOGO_HEIGHT;
      icons[f][DELTAY] = random(1, 6);
      //Serial.print(F("x: "));
      //Serial.print(icons[f][XPOS], DEC);
      //Serial.print(F(" y: "));
      //Serial.print(icons[f][YPOS], DEC);
      //Serial.print(F(" dy: "));
      //Serial.println(icons[f][DELTAY], DEC);
    }
    snowflakeinit = true;
  }

  // Draw each snowflake:
  for(f=0; f< NUMFLAKES; f++) {
    display.drawBitmap(icons[f][XPOS], icons[f][YPOS], bitmap, w, h, WHITE);
  }
  // Then update coordinates of each flake...
  for(f=0; f< NUMFLAKES; f++) {
    icons[f][YPOS] += icons[f][DELTAY];
    // If snowflake is off the bottom of the screen...
    if (icons[f][YPOS] >= display.height()) {
      // Reinitialize to a random position, just off the top
      icons[f][XPOS]   = random(1 - LOGO_WIDTH, display.width());
      icons[f][YPOS]   = -LOGO_HEIGHT;
      icons[f][DELTAY] = random(1, 6);
    }
  }
}
```
