# FiniteStateMachine

Project by Karl Crofskey, 2183664.  
For MG7013 Embedded Systems.  

# Project Requirements-

The purpose of this project is create a finite state machine in the form of a simple game. Here the specific game screens (minimum: a start screen, the actual game, a pause screen and an end screen) represent the states of the state machine, and transitions occur when button presses are detected or internal conditions are met.

The game and relevant screens will be displayed on an 'Adafruit SSD1306' 128x64 pixel OLED display. This communicates with a Teensy microcontroller via the I<sup>2</sup>C communication protocol.

A player score should be displayed, and the game should increase in difficulty as the game runs.

Pressing the button(s) should trigger an external interrupt, and they should be debounced in order to prevent multiple presses from being registered where only one occured.

# Introduction-

The game being developed for this project is a simple 'Car Racer'.

It takes place on a road converging into the screen (the horizon).

Cars will appear from this furthest most point, and move 'backwards' as the player's car - travelling at a greater velocity - gradually approaches them.

The player must move left and right to avoid these cars, and the aim of the game is to successfully pass a target amount of cars without colliding with either the road edges or these cars.


# Circuit Schematic-
<img src="https://i.ibb.co/GR4jYhZ/schematic.jpg" alt="schematic" border="0">

Above is the circuit schematic for the microcontroller, display and peripherals.

* The SSD1306 display has 4 lines which need to be connected (Vcc and GND being two of them).
* The I<sup>2</sup>C SDA (serial data) line is connected to the analog pin 4 on the Teensy microcontroller.
* The I<sup>2</sup>C SCL (serial clock) line is connected to analog pin 5.
* __Note:__ Both of these lines require a pull-up resistor attached to them (to +Vcc). Data transmission pulls the voltage of the line down to 0V due to the open-drain MOSFET interface of I<sup>2</sup>C (as per below). These are internally connected / included in the SSD1306 IC, hence were not pictured on the schematic.

<img src="http://rheingoldheavy.com/wp-content/uploads/2015/01/I2C_Pull_Up_Example.png">

Hienzsch, D. (2015, January 16). _I2C Pull Up Resistors._ Retrieved from https://rheingoldheavy.com/i2c-pull-resistors/

* A potentiometer is connected to analog pin 0 (as an input). The variable resistance provides a voltage between 0 and Vcc (+3.3V) on the input, which will be read and used to control the horizontal position of the car (as a mapped value).

* Two buttons are connected to interrupt capable digital pins (also as inputs). These will be the 'start' and 'pause' buttons to progress through the game states. When a button is pressed, a connection to ground is formed and the detected negative voltage edge on the line will trigger an interrupt service routine to be called (to capture this 'button pressed' event). These inputs will be configured to have internal pullup resistors connected to them, so that the line is not floating (and can return to +Vcc) when the button is not pressed - also not pictured.


# State Machine Design-
<img src="https://i.ibb.co/5ncZTbp/statemachine.jpg" alt="statemachine" border="0">

This is a Moore state machine design, as the state machine action depends only on the active state.   
Typically, this is just displaying the current state's screen / animation.  
* The __START__ and __LOAD__ states are progressed by pressing the start button.  
* The __RUNNING__ state toggles with the __PAUSED__ state by pressing the pause button.  
* The game engine runs in one state (see above right), and the pause state is a "pause" text overlay over the current game frame. 
* The __RUNNING__ state transitions to either the __SUCCESS__ or __GAMEOVER__ state, depending on the outcome of the game.
* Pressing start in either of these states transitions back to the __START__ state.  

The corresponding state actions are as follows:
* `displayStartScreen()` - the screen the player is first met with. Introduces the game.  
* `displayLoadScreen()` - prompts the player to calibrate / reset the potentiometer to reset the starting position of the car. This is required as the knob is a physical mechanism (superceeding any software reset done).  
* `runGame()` - run the game engine, until the player wins or loses.  
* `displayPaused()` - hold the game's current frame, until the player re-presses pause.  
* `displayWinScreen()` - reward the player with a victory animation.  
* `displayLoseScreen()` - consolidate the player with a defeat screen.  

Transitions between states depend on these 'events':
* `Start_Pressed` - set in the start button interrupt service routine.
* `Pause_Pressed` - similarly for the pause button.  
* `Collision` - set when the player's car collides with the road edges or with any oncoming car in the game.  
* `Win` - set when the player successfully passes the required number of cars (in this specific instance).  

__Note:__ As the start and pause button 'pressed flag' latches on when the corresponding button is pressed, these need to be reset when transitioning to a state checking for these button presses (to further transition). This prevents improper state transitioning - for example, if the start button was pressed during the game running state, the result (if not reset) would be immediately restarting the game when it was won or lost. The gameover or game won screen would not be visible to the player.

# Physical Circuit-
<img src="https://i.ibb.co/FxKTJ7G/breadboardcircuit-annotated.jpg" alt="breadboardcircuit-annotated" border="0">

Above is the breadboard implementation of the circuit.  

The left button pauses the game and the right button is the 'start' button (for progressing through the menu screens).

The relevant pins used on the Teensy microcontroller are annotated as above.

# Code Implementation-
## Game Engine
The game engine, runGame(), runs once per state machine cycle when the state machine is in the 'running' state. This is, until the game returns either 'collision' or 'win' - at which point a transition to the relevant end screen state occurs.

The game engine functions as follows:
* If the game has started, reset game variables to their initialized (typically zero) value.
```javascript
  //reset game variables for re-start of game
  if (gameTime_ms == 0){
    car_prox = 0; lastCar_ms = 0; launchCar = false; lastCarMove_ms = 0;
    car_count = 0; carLaunchDelay_ms = CAR_LAUNCHDELAYMAX_MS; carMoveDelay_ms = CAR_MOVEDELAYMAX_MS;
    lastMedianChange_ms = 0; medianState = 0;
  }
```
* Read the analog value of the potentiometer. Update the current average potentiometer value, then map this average (between 1 and 1023) to a position between the road's edges. This represents the centre point of the car.
```javascript
  //calculate position of user's car
  uint32_t potValue = analogRead(A0); //read potentiometer value
  potAvg = 0.1*potValue + 0.9*potOld; //implement rolling average
  potOld = potAvg;
  uint32_t posValue = map(potAvg,1,1023,ROAD_L_EDGE, ROAD_R_EDGE); //map to car centre position
```
* Draw the road lines. The lines of the median strip cyclically toggle between 4 intermediary states every second.
```javascript
  drawRoad(medianState);
  
  //determine if median strip needs to be alternated (every 250ms)
  if ((gameTime_ms - lastMedianChange_ms) > 250){
    lastMedianChange_ms = gameTime_ms;
    if(medianState==0){medianState=1;}
    else if(medianState==1){medianState=2;}
    else if(medianState==2){medianState=3;}
    else{medianState=0;}
  }
```
* Draw the player's car. The top left corner for the car bit map will be the (x,y) point: (car centre - car width/2, fixed y position - car height/2).
```javascript
  drawCar(posValue);
```
* Set the 'launch car' flag (and update the variable tracking this time) if the period between oncoming cars has passed.
```javascript
  //launch a car depending if carLaunchDelay_ms threshold reached
  //when carLaunchDelay_ms < 'time to move across screen' -> immediately launches once the previous car is 'done'
  if ((gameTime_ms - lastCar_ms) > carLaunchDelay_ms){
    lastCar_ms = gameTime_ms;
    launchCar = true;
  }
```
* Draw the approaching car(s). 'Car proximity' is incremented, depending on the move delay, and results in the y position of the car increasing. 'nextCarSide' is a random side of the road (left, centre, right, left & right, left & centre, right & centre) that the car(s) will travel down - there is a 'switch case' within carApproaching() to draw at the appropriate positions depending on this.
* When the car reaches the end of the road... reset variables for the next car and increment the 'cars passed' count.
* The 'cars passed' count is used to compare to the win target - once the threshold has been reached, the game ends and the player wins the game.
* It further is used to periodically decrement the launch delay and move delay periods (to a minimum of zero). The modulo '%' operator is used - 'every 2 cars' is equivalent to the remainder of the number of cars divided by this decrement step (2) being zero.
```javascript
  //draw the approaching cars, moving downwards depending on carMoveDelay_ms time
  if (launchCar){
      carApproaching(car_prox,nextCarSide); //car approaching of distance away, and position designator
      if (millis() - lastCarMove_ms > carMoveDelay_ms){ //carMoveDelay determines speed of car approach 50 -> 0.
        lastCarMove_ms = millis();
        car_prox = car_prox + 1; //car proximity 0 (top of road) to road height (bottom of screen)
      } 
      //when car reaches end of road...    
      if(car_prox > ROAD_H){
        car_prox = 0; //reset car distance variable
        launchCar = false; //car no longer on road
        car_count++; //increment cars passed
        nextCarSide = getRandomSide(); //for next car

        //win if count > threshold. 
        //alternatively, game time could correspond to distance travelled.
        if (car_count == NUMCARS){ return win;}

        //decrease car delays evey delayStep # cars
        if ((car_count > 0) and (car_count % DELAYSTEP) == 0){
          carLaunchDelay_ms = max(carLaunchDelay_ms - CARLAUNCH_DECR,0);
          carMoveDelay_ms = max(carMoveDelay_ms - CARMOVE_DECR,0);
        }
      }
    }
```
* Check for collisions between the player's car and the road edges. If the left or right edge of the player's car crosses the left or right (respectively) edge of the road, that results in a collision. 
* Further check for collisions between the player's car and any approaching cars in the 'collision zone' (between 5 and 10 pixels above the player's car). There is a 'switch case' within collisionDetectionCar() depending on the sides of the road the car(s) are coming down - but it also involves checking for boundary overlaps.
* If either collision case occurs, the game ends and the player loses the game.
```javascript
  //check for collisions with road & approaching cars (allowing for "clipping" if passed)
  if (collisionDetectionRoad(posValue)){return collision;}
  if((car_prox > ROAD_H-10) and (car_prox < ROAD_H-5) and (collisionDetectionCar(posValue,nextCarSide))){
    return collision;
  }
```
* Update the game timer and the game information being displayed to the player (cars remaining).
* Display the buffer contents (all of the bitmaps and text drawn) to the screen.
* Return that no ending condition has been met - the game continues.
```javascript
  //display game progress text
  displayCarsRemaining(NUMCARS, car_count);
  display.display(); //write buffer contents to screen
  gameTime_ms = millis() - gameStartTime_ms; //update game timer
  return none; //'none' return = game continues
```

## Finite State Machine
Every program cycle, the state machine calls the corresponding action of the 'current_state' of the game through use of a 'switch case' statement. It further checks for transition conditions that would change this active state, which are reset upon transitioning.

When in the __START__ state:
* Draw the startup screen. This screen displays the title of the game "DXRacer 5000" and depicts a car (a bitmap the whole size of the screen). The screen toggles displaying "press start" text every second.
* If the start button has been pressed - transition to the __LOAD__ state.
```javascript
      case S_Start:
      //could add: startup animation
      //action: start screen alternates displaying "press start" text, every 1s
      displayStartScreen(startscreenstate);
      if ((millis() - startscreentime_ms) > 1000){
        startscreentime_ms = millis();
        startscreenstate = !startscreenstate;
      }
      //transition checks - 'start' proceeds to next screen
      if (start_pressed){
        current_state = S_Load;
        start_pressed = 0; //reset on transition - as next screen checks for this
      }
      break;
```
When in the __LOAD__ state:
* Draw the load screen. This screen displays the lines representing the x co-ordinates of the edges of the road and the centre of the player's car (in order to calibrate the position). 
* If the start button has been pressed, and proceeding to the game would not result in an instant collision - transition to the __RUNNING__ state, resetting game timer variables.
```javascript
    case S_Load:
      //load screen to calibrate steering wheel (potentiometer)
      //displayLoadScreen() returns false if would result in crash (with road edge) on game start
      //proceed if 'start' and no collision would occur
      canLoad = displayLoadScreen();
      if (start_pressed and canLoad){
        current_state = S_Running;
        gameStartTime_ms = millis(); //time when start button was pressed
        gameTime_ms = 0; //reset game time
        start_pressed = 0;
        pause_pressed = 0; //in case it was latched (which resulted in pausing the load screen)
      } else{
        start_pressed = 0;
      }
      break;
```
When in the __RUNNING__ state:
* If the pause button has been pressed, transition to the __PAUSED__ state. This is called before the state action so that the display is not cleared - the current game frame remains on the screen when the game is paused.
* Otherwise, run the game (as per engine above). Check for the game returning 'collision' or 'win' conditions, and respectively transition to the __WINNING__ or __GAMEOVER__ state respectively. If the game returns 'none', the current state remains this __RUNNING__ state. 
```javascript
    case S_Running:
      //could have "startofGame()" = countdown + driving past chequered start line
      //run game until win or gameover
      if (pause_pressed){
        current_state = S_Paused; //pauses game
        pause_pressed = 0;
      }else{ //moves out of 'game running' state in collision / win events
          gameReturn g = runGame();
          if (g == collision){
            current_state = S_Gameover;
            start_pressed = 0;
            gameovertime_ms = millis();
          }
          else if(g == win){
            current_state = S_Winning;
            start_pressed = 0;
            }
      }
      break;
```
When in the __PAUSED__ state:
* Display "paused" text over the current game frame, indicating the game has been paused.
* Transition back to the __RUNNING__ state upon a second press of the pause button.
```javascript
    case S_Paused:
      //display "pause" text, keeping current frame on screen
      displayPause();
      if (pause_pressed){
        current_state = S_Running;
        pause_pressed = 0;
      }
      break;
```
When in the __WINNING__ state:
* Draw the win screen. This screen depicts a trophy and includes falling snowflakes that are initialized upon first entering the state.
* When the start button is pressed, transition to the __START__ state resetting state variables. This is so the start (and other) screens display consistently when staes are revisited.
```javascript
    case S_Winning:
      //alternating win screen
      displayWOO();
      if(start_pressed){
        display.clearDisplay();
        current_state = S_Start;
        start_pressed = 0;
        startscreenstate = 0; //for screen display consistency
        snowflakeinit = 0; //^
      }
      break;
```
When in the __GAMEOVER__ state:
* Display "boom" text over the current game frame (for 1 second from the time of state transition), indicating a crash has occured.
* Draw the gameover screen. This screen depicts a crashed car and alternates 'steam lines' every second.
* When the start button is pressed, transition to the __START__ state resetting state variables.
```javascript
    case S_Gameover:
      //display "boom" text if crash
      //alternating gameover screen
      if ((millis() - gameovertime_ms) < 1000){
        displayBOOM();
      }else{
        displaygameover(endscreenstate);
      }
      if ((millis() - endscreentime_ms) > 1000){
        endscreentime_ms = millis();
        endscreenstate = !endscreenstate;
      }
      if(start_pressed){
        display.clearDisplay();
        current_state = S_Start;
        start_pressed = 0;
        startscreenstate = 0; endscreenstate = 0;
      }
      break;
```

# Project Video-
<a href="http://www.youtube.com/watch?feature=player_embedded&v=MCOlxTB5z3w
" target="_blank"><img src="http://img.youtube.com/vi/MCOlxTB5z3w/0.jpg" 
alt="IMAGE ALT TEXT HERE" width="240" height="180" border="10" /></a>

Above is a supplementary video showing the game running and an explanation of the source code.

# Verification-
<img src="https://i.ibb.co/vhTfM8h/states.jpg" alt="states" border="0">

The above image shows all possible states of the game can be reached. Transitions between the states were as expected when using the start/pause push buttons, as according to the state transition diagram.

# Discussion-

* Control of the player's car is quite rudimentary. The player, via turning the potentiometer, controls the final position of the car. An extension for the game would be having the potentiometer represent 'turn left' and 'turn right' (from the centre potentiometer point), as opposed to directly mapping to discrete positions. The degree of the turn would correlate to the acceleration in that direction. This would add complexity because the player would then need to gauge the degree of turning required in order to follow the bend of the road or avoid obstacles (and yet, not have an unrecoverable amount of momentum from 'over-turning').
* An [XY axis joystick](https://www.gearbest.com/development-boards/pp_76239.html) could be utilised instead of the potentiometer to control the player car's movement. An advantage the joystick has over the potentiometer is that it physically resets to a centred neutral position when not in use (via a spring mechanism). This would eliminate the need for the 'loading screen' state. The degree of the (horizontal) turn could either map to a continuous acceleration scale or be separated into discrete threshold breakpoints where the acceleration amount increases. 
* Movement in the Y axis could correlate either to a limited vertical degree of freedom (the car can move 'down the road' a certain amount), or alternatively, correlate to the action of accelerating and braking. Changing the velocity of the car would affect the rate at which elements on the screen appear to travel towards the player. This could be conveyed on the screen by a 'km/h' meter or by increasing the rate at which a distance meter increases/decreases.
* The current win condition of passing a certain amount of cars is binary in that the player either wins or loses. There is no 'degree of winning'. The objective of the game would preferably be either: travel the furthest distance within a set time, or travel a target distance in the fastest time. Both of the win conditions promote continued playing for improvement, provided there is sufficient difficulty, and naturally lead to having 'high-scores'. These could be saved to the microcontroller's non-volatile memory.
* Supplementary to high-scores would be 'phantom racing'. That is, the game saving all actions the player makes, and then - if that game resulted in a high-score -  being able to race against a car that follows that exact movement pattern.
* Initially, it was intended for the player to travel a set race track. This would involve the player having to turn left and right according to bends in the road that the player has to sequentially overcome. This was not implemented due to difficult in realising the road graphics with the chosen game perspective. Implementation of car turning would help realise this, where, turning the player's car would result in shifting and rotating the curved edges of the road to capture the new field of view and change in relative distances between the (now rotated) car and the road's edges.
* Alternatively, a branching path for the game would have the player race against opponents around a race track with a top down view point. Here, turning would be relative to the player car's forward facing direction.
* More states could be added to the state machine to add to the game's complexity. For example, having a 'start menu' which leads to multiple, selectable options ('start game', 'options', 'high-scores'). The in game engine could further utilise more than one state - for example having 'accelerating', 'braking' and 'maintaining speed' states depending on the player's input. Or, 'travelling normally' and 'sustaining damage' states, where there is a threshold of collision damage allowed before the game is over, rather than an instant-lose condition. 
* Additionally, animations (specifically a start menu and a game introductory sequence) could be captured in their own states. My idea for the 'game running' state was that it would start with a '3', '2', '1' countdown sequence and with the player's car passing over a chequered flag on the road surface.
* The game is finally limited in that only one car (or set of cars) can appear on the screen at any one time. Having multiple cars on the screen would emphasise the requirement of 'weaving' to be able to succeed at the game. For this, the game engine needs to be adjusted slightly. Each car would need its own position values (either a 2D array, or an object oriented implementation), with the game engine then drawing all cars that are currently visible on the screen.


Most of the difficulty within this project was discovering and resolving edge cases in which the game states would not transition as expected. The game instantly restarting if the start button had been pressed while the game was running was one example. Another was pressing the pause button during the load screen state would end up pausing the load screen upon transition to the game running state. Both cases were resolved by making sure the 'pressed' flags were reset before transitioning to a state that specifically checked for them. Though an important learning point was "just because I don't expect (the button) to be pressed, doesn't mean it won't be (by the player)".  



# IMAGES AND REFERENCES
<img src="https://i.ibb.co/V2H6Txn/lcdassistant.jpg" alt="lcdassistant" border="0"> 

Kwiecie≈Ñ, R. _LCD Assistant_. Retrieved from http://en.radzio.dxp.pl/bitmap_converter/

[LCD Assistant](http://en.radzio.dxp.pl/bitmap_converter/) was used to convert monochrome bitmaps to an array of bytes, corresponding to bits (each pixel) that needed to be turned on in order to reproduce the image on the display.  

Below are the images used:  

<img src="https://i.ibb.co/YXXHpGh/mazda-323f-1993-2.jpg" alt="mazda-323f-1993-2" border="0"><img src="https://i.ibb.co/k1RwF41/mazda-323f-1993-tiny.jpg" alt="mazda-323f-1993-tiny" border="0">  

outlines. (2006-2019). _1998 Mazda 323F Lantis F Hatchback blueprints free._ Retrieved from https://getoutlines.com/blueprints/3143/1998-mazda-323f-lantis-f-hatchback-blueprints

<img src="https://i.ibb.co/chX98p3/render-97.png" alt="render-97" border="0"><img src="https://i.ibb.co/y45htKp/dxracer.png" alt="dxracer" border="0"><img src="https://i.ibb.co/bv4p8rv/dxracer-RIP.png" alt="dxracer-RIP" border="0">  

Weeeeeee. (2007, May 15). _Porche 911 Turbo._ Retrieved from https://gamebanana.com/sprays/21984

<img src="https://i.ibb.co/7nwqyK3/tropy-award.jpg" alt="tropy-award" border="0"><img src="https://i.ibb.co/BKYy9FG/tropy-award-pixel.jpg" alt="tropy-award-pixel" border="0">

bornzilla. (2016, September 20). _trophy-award.jpg._ Retrieved from https://bornzilla.eventsmart.com/events/meet-greet-soulzepi/tropy-award/ 



# APPENDIX 

__SSD1306 Example Code__  
The sample code used as reference for drawing to the OLED screen can be found [here](https://github.com/adafruit/Adafruit_SSD1306/blob/master/examples/ssd1306_128x64_i2c/ssd1306_128x64_i2c.ino).    
This was for the 128x64 pixel, I2C protocol specific display type.

A modified version of the 'snowflake example' (testanimate) within this sample program was used as part of the game's victory screen. 

Fried, L., Ladyada. (2018, November 14). _Adafruit_SSD1306._ Retrieved from https://github.com/adafruit/Adafruit_SSD1306/blob/master/examples/ssd1306_128x64_i2c/ssd1306_128x64_i2c.ino 

__Source Code__
 
```javascript
/**************************************************************************
 This is an example for our Monochrome OLEDs based on SSD1306 drivers

 Pick one up today in the adafruit shop!
 ------> http://www.adafruit.com/category/63_98

 This example is for a 128x32 pixel display using I2C to communicate
 3 pins are required to interface (two I2C and one reset).

 Adafruit invests time and resources providing this open
 source code, please support Adafruit and open-source
 hardware by purchasing products from Adafruit!

 Written by Limor Fried/Ladyada for Adafruit Industries,
 with contributions from the open source community.
 BSD license, check license.txt for more information
 All text above, and the splash screen below must be
 included in any redistribution.
 **************************************************************************/
#include <Arduino.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET     4 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

//for snowflakes animation example
#define NUMFLAKES     20
#define LOGO_HEIGHT   16
#define LOGO_WIDTH    16
#define XPOS   0 // 'icons' array index (snowflake x,y,dy position variables)
#define YPOS   1
#define DELTAY 2
const unsigned char PROGMEM logo_bmp[] = { 
  B00000000, B11000000,
  B00000001, B11000000,
  B00000001, B11000000,
  B00000011, B11100000,
  B11110011, B11100000,
  B11111110, B11111000,
  B01111110, B11111111,
  B00110011, B10011111,
  B00011111, B11111100,
  B00001101, B01110000,
  B00011011, B10100000,
  B00111111, B11100000,
  B00111111, B11110000,
  B01111100, B11110000,
  B01110000, B01110000,
  B00000000, B00110000 
};
bool snowflakeinit = false; //initialize snowflake positions once per gameover screen

//function prototypes
void ISR_Start();
void ISR_Pause();
void testanimate(const uint8_t *bitmap, uint8_t w, uint8_t h);

//game screen bitmaps
const uint8_t car_img[] PROGMEM = {
  0x0F, 0xF0, 0x10, 0x08, 0xEF, 0xF7, 0x28, 0x14, 0x40, 0x02, 0x44, 0x22, 0x7F, 0xFE, 0x60, 0x06
}; //16x8 pixels
const uint8_t startscreen_img[] PROGMEM = {
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x3F, 0xE3, 0xE1, 0xDF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x3F, 0xF3, 0xF3, 0xDF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1C, 0x78, 0xF7, 0xCC, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1C, 0x38, 0x7F, 0x0C, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1C, 0x38, 0x3E, 0x0C, 0xE3, 0xE0, 0x7C, 0x78, 0xFE, 0x1F, 0xCF, 0x87, 0xC3, 0xE0, 0x00,
	0x00, 0x1C, 0x38, 0x1C, 0x0F, 0xC3, 0xF0, 0xFC, 0xFE, 0xFE, 0x1F, 0xDF, 0xCF, 0xE7, 0xF0, 0x00,
	0x00, 0x1C, 0x38, 0x1E, 0x0F, 0x80, 0x31, 0xCD, 0xCE, 0x76, 0x1F, 0xB9, 0xDC, 0xEF, 0x70, 0x00,
	0x00, 0x1C, 0x18, 0x3E, 0x0D, 0xC3, 0xF1, 0x8D, 0xFE, 0x70, 0x18, 0x39, 0xDC, 0xEE, 0x70, 0x00,
	0x00, 0x1C, 0x38, 0x77, 0x0C, 0xE7, 0xF1, 0x81, 0xFC, 0x70, 0x1F, 0xB9, 0xDC, 0xEE, 0x70, 0x00,
	0x00, 0x1C, 0x70, 0xE7, 0x8C, 0x76, 0x31, 0xC1, 0xC0, 0x70, 0x1F, 0xBB, 0xDC, 0xEE, 0x70, 0x00,
	0x00, 0x3F, 0xE3, 0xE3, 0xDE, 0x7B, 0xF9, 0xFD, 0xFE, 0xF8, 0x01, 0xDF, 0x9F, 0xCF, 0xE0, 0x00,
	0x00, 0x3F, 0xC3, 0xE3, 0xDE, 0x7B, 0xF8, 0xFC, 0x7E, 0xF8, 0x01, 0xC0, 0x0F, 0x87, 0xC0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xDF, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xDF, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xE0, 0x01, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xC0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x70, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x04, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1D, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x14, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
	0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00,
	0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00,
	0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x80, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x79, 0xF8, 0x00, 0x11, 0x00, 0x09, 0x14, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x73, 0xF8, 0x07, 0xC8, 0xFF, 0xF0, 0x1F, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x07, 0xE3, 0xFF, 0x08, 0xFF, 0xC0, 0x00, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x06, 0x00, 0x00, 0x13, 0x9F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x80, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
	0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xE1, 0xC0, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x19, 0x80, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00
}; //128x64 pixels
const uint8_t gameoverscreen_img[] PROGMEM ={
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x40, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x9F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x9F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x1F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x10, 0x00, 0x03, 0x3F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x10, 0x00, 0x03, 0x3F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF
};
const uint8_t gameoverscreen_imgsteam[] PROGMEM = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFE, 0x7F, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x3F, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x9F, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xDF, 0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xBF, 0xFF, 0xDF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x3F, 0xFF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x7F, 0xFF, 0x9F, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFE, 0x7F, 0xFF, 0xBF, 0xFB, 0xFF, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFC, 0xFF, 0xDF, 0xBF, 0xFB, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xF9, 0xFF, 0xFC, 0x00, 0x1F, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xF3, 0xFF, 0x81, 0x00, 0x00, 0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0x7F, 0xF7, 0xFF, 0xC3, 0x00, 0x04, 0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xEF, 0xFF, 0x46, 0x00, 0x04, 0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xEF, 0xFF, 0x04, 0x00, 0x04, 0x00, 0x67, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xEF, 0xFF, 0x04, 0x00, 0x04, 0x00, 0x77, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xEF, 0xF8, 0x04, 0x00, 0x06, 0x00, 0x17, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xEF, 0xE8, 0x04, 0x00, 0x03, 0x00, 0x13, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xE8, 0x04, 0x00, 0x01, 0x00, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xC8, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF9, 0xF0, 0x0C, 0x00, 0x06, 0x00, 0x01, 0x00, 0x04, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFD, 0xF0, 0x04, 0x00, 0x02, 0x00, 0x03, 0x00, 0x05, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFD, 0x00, 0x02, 0x00, 0x03, 0x00, 0x02, 0x00, 0x05, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF2, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06, 0x00, 0x05, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF3, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x0D, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE1, 0xE0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE1, 0xE0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0xF0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0xF0, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x9E, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x9E, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF1, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF7, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x1F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x06, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x10, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x18, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x08, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x08, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x04, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x04, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x10, 0x00, 0x03, 0x3F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x10, 0x00, 0x03, 0x3F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF
};
const uint8_t winscreen_img[] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0x80, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x70, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFF, 0xF3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x07, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0xC0, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x01, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x80, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x01, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x80, 0x1D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x80, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDC, 0x01, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xC0, 0x39, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0x01, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x60, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x03, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x30, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x07, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x0F, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0C, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x1E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x7C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0xC0, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x03, 0xE0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x78, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x1F, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1E, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x7E, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x07, 0x8F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xF8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xE0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0xFF, 0xCD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x78, 0xFF, 0xFF, 0x0E, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xF0, 0x3F, 0xFE, 0x07, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF8, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xF6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xE0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7B, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xE8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7B, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xF8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x02, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00
};

//game difficulty parameters
//**note: move delay <30, feels like significant increase in speed
const uint8_t NUMCARS = 8 ; //number of cars to win the game
const uint8_t DELAYSTEP = 2; //number of cars before delay decrements
const uint16_t CAR_LAUNCHDELAYMAX_MS = 2000; //starting / reset delay values
const uint8_t CAR_MOVEDELAYMAX_MS = 100;
const uint8_t CARLAUNCH_DECR = 250; //decrement amounts per iteration
const uint8_t CARMOVE_DECR = 25;

//global variables for game
const uint8_t ROAD_W = 88; //(bottom of) road width
const uint8_t ROAD_H = 30; //2d height of road
const uint8_t ROAD_DEL = 30; //pixel convergence of road lines (parallax)
const uint8_t ROAD_CEN = display.width()/2; //centre point of road
const uint8_t ROAD_L_EDGE = ROAD_CEN - ROAD_W /2; //bottom left point of road
const uint8_t ROAD_R_EDGE = ROAD_CEN + ROAD_W /2;
const uint8_t ROAD_Y = display.height() - ROAD_H; //y pixel position of road line = 34

const uint8_t CAR_H = 8; //car dimensions
const uint8_t CAR_W = 16;
const uint8_t CAR_Y = 55; //car is fixed vertically, can only move horizontally

enum sideOfRoad {left_side, down_centre, right_side, both_sides, left_cen, right_cen}; //sides of the road for oncoming cars
enum gameReturn {none, collision, win}; //game return variable (for state transition from 'running')
enum State {S_Start, S_Load, S_Running, S_Paused, S_Winning, S_Gameover}; //FSM states
State current_state = S_Start; //state machine initialization
uint32_t gameStartTime_ms = 0; //time 'game running' started
uint32_t gameTime_ms = 0; //time 'game running' elapsed
float potAvg = 0; float potOld = 0; //averaging potentiometer value to mitigate noise
bool canLoad = false; //can progress past loading screen flag

//global variables for buttons
uint8_t startButtonPin = 11; //digital Teensy pin
uint8_t pauseButtonPin = 12;
const uint8_t DEBOUNCE_DELAY_MS = 200;
volatile bool start_pressed = 0; //flags for 'button has been pressed'
volatile bool pause_pressed = 0;

//CAR FUNCTIONS
/* return a random 'sideOfRoad' (for the approaching cars) */
sideOfRoad getRandomSide(){
  sideOfRoad values[6] = {left_side, down_centre, right_side, both_sides, left_cen, right_cen};
  uint8_t r = (uint8_t)random(0,6);
  return values[r]; 
}

/* draw road edges and median strip */
void drawRoad(uint8_t med){
  display.drawLine(ROAD_L_EDGE+ROAD_DEL, ROAD_Y, ROAD_L_EDGE, ROAD_Y+ROAD_H, WHITE); 
  display.drawLine(ROAD_R_EDGE-ROAD_DEL, ROAD_Y, ROAD_R_EDGE, ROAD_Y+ROAD_H, WHITE);
  
  //alternate median strip lines (depending on 'medianState')
  //for loop used as initially much smaller spacing (the i increment)
  if (med==0){
    for (uint8_t i = 0; i<ROAD_H; i=i+20){
    display.drawFastVLine(ROAD_CEN, ROAD_Y+i, 5, WHITE);}
  }
  else if(med==1){
    for (uint8_t i = 5; i<ROAD_H; i=i+20){
    display.drawFastVLine(ROAD_CEN, ROAD_Y+i, 5, WHITE);}
  }
  else if(med==2){
    for (uint8_t i = 10; i<ROAD_H; i=i+20){
    display.drawFastVLine(ROAD_CEN, ROAD_Y+i, 5, WHITE);}
  }
  else{
    for (uint8_t i = 15; i<ROAD_H; i=i+20){
    display.drawFastVLine(ROAD_CEN, ROAD_Y+i, 5, WHITE);}
  }
}

/* draws player's car*/
void drawCar(int cen){ 
  //note: need to offset car centre by car width/height, as draws from top left corner
  //display.drawRect(cen-(CAR_W/2), CAR_Y, CAR_W, CAR_H, WHITE);
  display.drawBitmap(cen-(CAR_W/2), CAR_Y, car_img, CAR_W, CAR_H, WHITE);
}

/* detects collision between player car and road edges */
bool collisionDetectionRoad(uint8_t car_cen){
  if ((car_cen - CAR_W/2)< ROAD_L_EDGE){ //if player car's left side < road left edge
    return true;
  }
  else if ((car_cen + CAR_W/2)>ROAD_R_EDGE){ //if player car's right side > road right edge
    return true;
  }
  else {
    return false;
  }
}

/* detect collision between player's car and approaching cars within collision proximity */
bool collisionDetectionCar (uint8_t car_cen, sideOfRoad side){
  switch(side){
    case left_side: //collision if player car's left side < left car's right
      if((car_cen - CAR_W/2) < (ROAD_CEN - ROAD_W/4 + CAR_W/2)){return true;}
      else {return false;}

    case right_side: //collision if players car's right side > right car's left
      if((car_cen + CAR_W/2) > (ROAD_CEN + ROAD_W/4 - CAR_W/2)){return true;}
      else {return false;}

    case both_sides: //check player within central area (right edge of left, left edge of right car)
      if((car_cen - CAR_W/2) < (ROAD_CEN - ROAD_W/4 + CAR_W/2)){return true;}
      else if((car_cen + CAR_W/2) > (ROAD_CEN + ROAD_W/4 - CAR_W/2)){return true;}
      else {return false;}

    case down_centre: //check player car clears centre car from either road side
      if((car_cen < ROAD_CEN) and ((car_cen + CAR_W/2) > (ROAD_CEN - CAR_W/2))){return true;}
      if((car_cen > ROAD_CEN) and ((car_cen - CAR_W/2) < (ROAD_CEN + CAR_W/2))){return true;}
      else {return false;}
    
    case left_cen: //player car's left edge must be right of centre car's right
      if((car_cen - CAR_W/2) < ROAD_CEN + CAR_W/2) {return true;}
      else {return false;}

    case right_cen: //player car's right edge must be left of centre car's left
      if ((car_cen + CAR_W/2) > ROAD_CEN - CAR_W/2) {return true;}
      else {return false;}
  }
  return false;
}

/* draw approaching cars */
void carApproaching(int car_prox, sideOfRoad side){
  //car gets bigger during vertical travel (x/30), x=0..30
  float car_scaling = (float)car_prox / (float)ROAD_H; 
  float car_scaling_size = min(car_scaling*10, 1.0);

  // int car_scaling_pos_right = map(car_prox,0,ROAD_H,ROAD_CEN + 0.5*ROAD_W - 0.75*ROAD_DEL, ROAD_CEN + 0.25*ROAD_W);
  // int car_scaling_pos_right = ROAD_CEN + 7 + car_prox/2 [i.e +7 to +22] <- 1/4line of road
  int car_scaling_pos_right = map(car_prox,0,ROAD_H,ROAD_CEN+10, ROAD_CEN+25); //hard coded to visually be centred
  int car_scaling_pos_left = map(car_prox,0,ROAD_H,ROAD_CEN-10, ROAD_CEN-25);

  switch (side){
    case left_side: //car moving down left
      //display.drawRect(car_scaling_pos_left-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_left-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    case down_centre: //car moving down centre
      //display.drawRect(ROAD_CEN-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(ROAD_CEN-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    case right_side: //car moving down right
      //display.drawRect(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    case both_sides:
      //display.drawRect(car_scaling_pos_left-(CAR_W/2*car_scaling_size),ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      //display.drawRect(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_left-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE); 
      break;

    case left_cen:
      //display.drawRect(car_scaling_pos_left-(CAR_W/2*car_scaling_size),ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      //display.drawRect(ROAD_CEN-(CAR_W/2*car_scaling_size),ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_left-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(ROAD_CEN-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    case right_cen:
      //display.drawRect(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      //display.drawRect(ROAD_CEN-(CAR_W/2*car_scaling_size),ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(ROAD_CEN-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    //case: car changing lanes? -> fixed final position to check for collision
    //note: size scaling changes bitmap frame size, instead of actually changing proportions
    //may need custom images for 'appearing' sequence
  }  
}

//DISPLAY FUNCTIONS
/* draw start screen with alternating "start" text */
void displayStartScreen(bool startscreenstate){
  display.clearDisplay();
  if (startscreenstate){ //startscreenstate is a flag that gets toggled in the state machine
    display.drawBitmap(0,0,startscreen_img,display.width(),display.height(),WHITE);
    display.setTextSize(1);                 
    display.setCursor(32,30);
    display.setTextColor(WHITE);             
    display.println(F("press start"));
  }else{
    display.drawBitmap(0,0,startscreen_img,display.width(),display.height(),WHITE);
  }
  display.display();
}
/* draw load screen - prompting player to calibrate potentiometer */
bool displayLoadScreen(){
  display.clearDisplay();
  display.setTextSize(1);                 
  display.setCursor(0,0);             
  display.println(F("Please calibrate steering wheel"));
  uint32_t potValue = analogRead(A0); //read potentiometer value
  potAvg = 0.1*potValue + 0.9*potOld; //update current average value (for noise mitigation)
  potOld = potAvg;
  uint32_t posValue = map(potAvg,1,1023,ROAD_L_EDGE, ROAD_R_EDGE); //map to car centre position
  display.drawFastVLine(posValue,32,5,WHITE);
  display.drawFastVLine(ROAD_L_EDGE,32,5,WHITE);
  display.drawFastVLine(ROAD_R_EDGE,32,5,WHITE);
  display.display();
  //return to 'canLoad' whether the game should be able to start (won't result in instant crash)
  if(collisionDetectionRoad(posValue)){
    return false;
  }else{
    return true;
  }
}
/* display "pause" text on screen */
void displayPause(){
  display.setTextSize(2);                  
  display.setCursor(28,10);             
  display.println(F("PAUSED"));
  display.display();
}
/* display 'you crashed' text to indicate a collision has occured */
void displayBOOM(){
  display.setTextSize(2);                  
  display.setCursor(0,0);             
  display.println(F("*^KABOOMv#"));
  display.display();
}
/* draw gameover screen and re-start prompt */
void displaygameover(bool endscreenstate){
  display.clearDisplay();
  if(endscreenstate){
    display.drawBitmap(0,0,gameoverscreen_img, display.width(),display.height(), WHITE);
  }else{
    display.drawBitmap(0,0,gameoverscreen_imgsteam, display.width(), display.height(), WHITE);
  }
  display.setTextSize(1);                  
  display.setCursor(10,2);
  display.setTextColor(BLACK);          
  display.println(F("Press start to try"));
  display.setCursor(90,12);
  display.println(F("again."));
  display.display();
}
/* draw game win screen */
void displayWOO(){
  display.clearDisplay();
  display.drawBitmap(0,0,winscreen_img,display.width(),display.height(),WHITE);
  display.setTextSize(1);                    
  display.setCursor(44,10);  
  display.setTextColor(BLACK);           
  display.println(F("WINNING"));
  testanimate(logo_bmp, LOGO_WIDTH, LOGO_HEIGHT);
  display.display();
}
/* display in game text indicating game progression */
void displayCarsRemaining(uint8_t num, uint8_t count){
  display.setTextSize(1);               
  display.setCursor(0,0);             
  display.print(F("Cars remaining: "));
  display.print(num - count);
}

/* THE GAME runs until it returns 'win' or 'collision' */
gameReturn runGame(){
  //note: one shared variable for car position 'carProx' = only one 'car' on screen at a time
  //object oriented implementation (each car has its own 'distance away') better if multiple concurrent cars are needed

  static uint16_t carLaunchDelay_ms = CAR_LAUNCHDELAYMAX_MS; //<- minimum time before next car launches (decreases)
  static uint8_t carMoveDelay_ms = CAR_MOVEDELAYMAX_MS; //<-- delay affects speed of car (decreases)

  static uint8_t car_prox = 0; //increases as cars move toward screen 0->30 (road_h)
  static uint32_t lastCar_ms = 0; //the last time a car was launched
  static uint32_t lastCarMove_ms = 0; //the last time the car on screen moved
  static bool launchCar = false; //flag for if a car is on the road
  static sideOfRoad nextCarSide = getRandomSide();
  static uint8_t car_count = 0; //numbers of sets of cars passed

  static uint8_t medianState = 0; //to alternate median strip
  static uint32_t lastMedianChange_ms = 0;

  //reset game variables for re-start of game
  if (gameTime_ms == 0){
    car_prox = 0; lastCar_ms = 0; launchCar = false; lastCarMove_ms = 0;
    car_count = 0; carLaunchDelay_ms = CAR_LAUNCHDELAYMAX_MS; carMoveDelay_ms = CAR_MOVEDELAYMAX_MS;
    lastMedianChange_ms = 0; medianState = 0;
  }
  //calculate position of user's car
  uint32_t potValue = analogRead(A0); //read potentiometer value
  potAvg = 0.1*potValue + 0.9*potOld; //implement rolling average
  potOld = potAvg;
  uint32_t posValue = map(potAvg,1,1023,ROAD_L_EDGE, ROAD_R_EDGE); //map to car centre position
  
  display.clearDisplay();

  //draw the road lines and the player's car
  drawRoad(medianState);
  drawCar(posValue);

  //determine if median strip needs to be alternated (every 250ms)
  if ((gameTime_ms - lastMedianChange_ms) > 250){
    lastMedianChange_ms = gameTime_ms;
    if(medianState==0){medianState=1;}
    else if(medianState==1){medianState=2;}
    else if(medianState==2){medianState=3;}
    else{medianState=0;}
  }
  
  //launch a car depending if carLaunchDelay_ms threshold reached
  //when carLaunchDelay_ms < 'time to move across screen' -> immediately launches once the previous car is 'done'
  if ((gameTime_ms - lastCar_ms) > carLaunchDelay_ms){
    lastCar_ms = gameTime_ms;
    launchCar = true;
  }
  //draw the approaching cars, moving downwards depending on carMoveDelay_ms time
  if (launchCar){
      carApproaching(car_prox,nextCarSide); //car approaching of distance away, and position designator
      if (millis() - lastCarMove_ms > carMoveDelay_ms){ //carMoveDelay determines speed of car approach 50 -> 0.
        lastCarMove_ms = millis();
        car_prox = car_prox + 1; //car proximity 0 (top of road) to road height (bottom of screen)
      } 
      //when car reaches end of road...    
      if(car_prox > ROAD_H){
        car_prox = 0; //reset car distance variable
        launchCar = false; //car no longer on road
        car_count++; //increment cars passed
        nextCarSide = getRandomSide(); //for next car

        //win if count > threshold. 
        //alternatively, game time could correspond to distance travelled.
        if (car_count == NUMCARS){ return win;}

        //decrease car delays evey delayStep # cars
        if ((car_count > 0) and (car_count % DELAYSTEP) == 0){
          carLaunchDelay_ms = max(carLaunchDelay_ms - CARLAUNCH_DECR,0);
          carMoveDelay_ms = max(carMoveDelay_ms - CARMOVE_DECR,0);
        }
      }
  }
    
  //check for collisions with road & approaching cars (allowing for "clipping" if passed)
  if (collisionDetectionRoad(posValue)){return collision;}
  if((car_prox > ROAD_H-10) and (car_prox < ROAD_H-5) and (collisionDetectionCar(posValue,nextCarSide))){
    return collision;
  }
  //display game progress text
  displayCarsRemaining(NUMCARS, car_count);
  display.display(); //write buffer contents to screen
  gameTime_ms = millis() - gameStartTime_ms; //update game timer
  return none; //'none' return = game continues
}

//MAIN- STATE MACHINE
void setup() {
  Serial.begin(9600);
  Wire.setClock(3400000);

  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3C for 128x32
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }
  //initializing button digital pins with interrupts attached
  pinMode(startButtonPin, INPUT_PULLUP);
  pinMode(pauseButtonPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(startButtonPin), ISR_Start, FALLING);
  attachInterrupt(digitalPinToInterrupt(pauseButtonPin), ISR_Pause, FALLING);

  display.setTextColor(WHITE);  //initial color
  display.display(); //initial buffer = Adafruit splash screen
  display.clearDisplay(); // Clear the buffer
  while (millis()<1000){} //delay to show Adafruit screen
}

void loop() {
  //'time when this screen occured' variables
  static uint32_t startscreentime_ms = 0;  static uint32_t gameovertime_ms = 0;  static uint32_t endscreentime_ms = 0;
  static bool startscreenstate = 0;  static bool endscreenstate = 0;
  switch (current_state){

    case S_Start:
      //could add: startup animation
      //action: start screen alternates displaying "press start" text, every 1s
      displayStartScreen(startscreenstate);
      if ((millis() - startscreentime_ms) > 1000){
        startscreentime_ms = millis();
        startscreenstate = !startscreenstate;
      }
      //transition checks - 'start' proceeds to next screen
      if (start_pressed){
        current_state = S_Load;
        start_pressed = 0; //reset on transition - as next screen checks for this
      }
      break;

    case S_Load:
      //load screen to calibrate steering wheel (potentiometer)
      //displayLoadScreen() returns false if would result in crash (with road edge) on game start
      //proceed if 'start' and no collision would occur
      canLoad = displayLoadScreen();
      if (start_pressed and canLoad){
        current_state = S_Running;
        gameStartTime_ms = millis(); //time when start button was pressed
        gameTime_ms = 0; //reset game time
        start_pressed = 0;
        pause_pressed = 0; //in case it was latched (which resulted in pausing the load screen)
      } else{
        start_pressed = 0;
      }
      break;

    case S_Running:
      //could have "startofGame()" = countdown + driving past chequered start line
      //run game until win or gameover
      if (pause_pressed){
        current_state = S_Paused; //pauses game
        pause_pressed = 0;
      }else{ //moves out of 'game running' state in collision / win events
          gameReturn g = runGame();
          if (g == collision){
            current_state = S_Gameover;
            start_pressed = 0;
            gameovertime_ms = millis();
          }
          else if(g == win){
            current_state = S_Winning;
            start_pressed = 0;
            }
      }
      break;

    case S_Paused:
      //display "pause" text, keeping current frame on screen
      displayPause();
      if (pause_pressed){
        current_state = S_Running;
        pause_pressed = 0;
      }
      break;

    case S_Winning:
      //alternating win screen
      displayWOO();
      if(start_pressed){
        display.clearDisplay();
        current_state = S_Start;
        start_pressed = 0;
        startscreenstate = 0; endscreenstate = 0; //for screen display consistency
        snowflakeinit = 0; //^
      }
      break;

    case S_Gameover:
      //display "boom" text if crash
      //alternating gameover screen
      if ((millis() - gameovertime_ms) < 1000){
        displayBOOM();
      }else{
        displaygameover(endscreenstate);
      }
      if ((millis() - endscreentime_ms) > 1000){
        endscreentime_ms = millis();
        endscreenstate = !endscreenstate;
      }
      if(start_pressed){
        display.clearDisplay();
        current_state = S_Start;
        start_pressed = 0;
        startscreenstate = 0; endscreenstate = 0;
      }
      break;
  }
}

void ISR_Start(){
  //debounce delay - ignore all negative edges for a period of time (200ms)
  //after the first, actual press, has been detected
  static uint32_t laststartpress_ms = 0;
  if ((millis() - laststartpress_ms) > DEBOUNCE_DELAY_MS){
    laststartpress_ms = millis();
    start_pressed = 1; //set flag indicating the button has been pressed
  }
}
void ISR_Pause(){
  static uint32_t lastpausepress_ms = 0;
  if (millis() - lastpausepress_ms > DEBOUNCE_DELAY_MS){
    lastpausepress_ms = millis();
    pause_pressed = 1;
  }
}
/*** COMMENTS ***********/
//128x64 pixels -> 30..98, 
//potValue rolling average?

//car = bit map
//collision with road state
//collision with approaching car
// queue cars using timers

//how to draw curved road?
//track / display time, metres left, fps

//exten: joystick: degree of acceleration, braking, steering
// speed control is level of agency on top of steering / handling.
//add more difficult courses (tight corners) where reckless acceleration is punished

//consideration of variable screen sizes -> distances relative to edge, proportional to total dimension

//draw snowflakes - modified
void testanimate(const uint8_t *bitmap, uint8_t w, uint8_t h) {
  static int8_t f, icons[NUMFLAKES][3];
  // Initialize 'snowflake' positions
  if(!snowflakeinit){
    for(f=0; f< NUMFLAKES; f++) {
      icons[f][XPOS]   = random(1 - LOGO_WIDTH, display.width());
      icons[f][YPOS]   = -LOGO_HEIGHT;
      icons[f][DELTAY] = random(1, 6);
      //Serial.print(F("x: "));
      //Serial.print(icons[f][XPOS], DEC);
      //Serial.print(F(" y: "));
      //Serial.print(icons[f][YPOS], DEC);
      //Serial.print(F(" dy: "));
      //Serial.println(icons[f][DELTAY], DEC);
    }
    snowflakeinit = true;
  }

  // Draw each snowflake:
  for(f=0; f< NUMFLAKES; f++) {
    display.drawBitmap(icons[f][XPOS], icons[f][YPOS], bitmap, w, h, WHITE);
  }
  // Then update coordinates of each flake...
  for(f=0; f< NUMFLAKES; f++) {
    icons[f][YPOS] += icons[f][DELTAY];
    // If snowflake is off the bottom of the screen...
    if (icons[f][YPOS] >= display.height()) {
      // Reinitialize to a random position, just off the top
      icons[f][XPOS]   = random(1 - LOGO_WIDTH, display.width());
      icons[f][YPOS]   = -LOGO_HEIGHT;
      icons[f][DELTAY] = random(1, 6);
    }
  }
}
```
