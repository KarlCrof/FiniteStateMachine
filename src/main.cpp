/**************************************************************************
 This is an example for our Monochrome OLEDs based on SSD1306 drivers

 Pick one up today in the adafruit shop!
 ------> http://www.adafruit.com/category/63_98

 This example is for a 128x32 pixel display using I2C to communicate
 3 pins are required to interface (two I2C and one reset).

 Adafruit invests time and resources providing this open
 source code, please support Adafruit and open-source
 hardware by purchasing products from Adafruit!

 Written by Limor Fried/Ladyada for Adafruit Industries,
 with contributions from the open source community.
 BSD license, check license.txt for more information
 All text above, and the splash screen below must be
 included in any redistribution.
 **************************************************************************/
#include <Arduino.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET     4 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

//for snowflakes animation example
#define NUMFLAKES     20
#define LOGO_HEIGHT   16
#define LOGO_WIDTH    16
#define XPOS   0 // 'icons' array index (snowflake position variables)
#define YPOS   1
#define DELTAY 2
const unsigned char PROGMEM logo_bmp[] = { 
  B00000000, B11000000,
  B00000001, B11000000,
  B00000001, B11000000,
  B00000011, B11100000,
  B11110011, B11100000,
  B11111110, B11111000,
  B01111110, B11111111,
  B00110011, B10011111,
  B00011111, B11111100,
  B00001101, B01110000,
  B00011011, B10100000,
  B00111111, B11100000,
  B00111111, B11110000,
  B01111100, B11110000,
  B01110000, B01110000,
  B00000000, B00110000 
};
bool snowflakeinit = false;

//function prototypes
void ISR_Start();
void ISR_Pause();
void testanimate(const uint8_t *bitmap, uint8_t w, uint8_t h);

//game screen bitmaps
const uint8_t car_img[] PROGMEM = {
  0x0F, 0xF0, 0x10, 0x08, 0xEF, 0xF7, 0x28, 0x14, 0x40, 0x02, 0x44, 0x22, 0x7F, 0xFE, 0x60, 0x06
};
const uint8_t startscreen_img[] PROGMEM = {
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xF8, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFC,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFE, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00,
	0x00, 0x3F, 0xE3, 0xE1, 0xDF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x3F, 0xF3, 0xF3, 0xDF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1C, 0x78, 0xF7, 0xCC, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1C, 0x38, 0x7F, 0x0C, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1C, 0x38, 0x3E, 0x0C, 0xE3, 0xE0, 0x7C, 0x78, 0xFE, 0x1F, 0xCF, 0x87, 0xC3, 0xE0, 0x00,
	0x00, 0x1C, 0x38, 0x1C, 0x0F, 0xC3, 0xF0, 0xFC, 0xFE, 0xFE, 0x1F, 0xDF, 0xCF, 0xE7, 0xF0, 0x00,
	0x00, 0x1C, 0x38, 0x1E, 0x0F, 0x80, 0x31, 0xCD, 0xCE, 0x76, 0x1F, 0xB9, 0xDC, 0xEF, 0x70, 0x00,
	0x00, 0x1C, 0x18, 0x3E, 0x0D, 0xC3, 0xF1, 0x8D, 0xFE, 0x70, 0x18, 0x39, 0xDC, 0xEE, 0x70, 0x00,
	0x00, 0x1C, 0x38, 0x77, 0x0C, 0xE7, 0xF1, 0x81, 0xFC, 0x70, 0x1F, 0xB9, 0xDC, 0xEE, 0x70, 0x00,
	0x00, 0x1C, 0x70, 0xE7, 0x8C, 0x76, 0x31, 0xC1, 0xC0, 0x70, 0x1F, 0xBB, 0xDC, 0xEE, 0x70, 0x00,
	0x00, 0x3F, 0xE3, 0xE3, 0xDE, 0x7B, 0xF9, 0xFD, 0xFE, 0xF8, 0x01, 0xDF, 0x9F, 0xCF, 0xE0, 0x00,
	0x00, 0x3F, 0xC3, 0xE3, 0xDE, 0x7B, 0xF8, 0xFC, 0x7E, 0xF8, 0x01, 0xC0, 0x0F, 0x87, 0xC0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xDF, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xDF, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xE0, 0x01, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xC0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x70, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x04, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1D, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x14, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
	0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00,
	0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0x00, 0x00,
	0x00, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x80, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x79, 0xF8, 0x00, 0x11, 0x00, 0x09, 0x14, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x73, 0xF8, 0x07, 0xC8, 0xFF, 0xF0, 0x1F, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x07, 0xE3, 0xFF, 0x08, 0xFF, 0xC0, 0x00, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x06, 0x00, 0x00, 0x13, 0x9F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00,
	0x00, 0x01, 0x80, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
	0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xE1, 0xC0, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x19, 0x80, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00
};
const uint8_t gameoverscreen_img[] PROGMEM ={
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x40, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x9F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x9F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x1F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x10, 0x00, 0x03, 0x3F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x10, 0x00, 0x03, 0x3F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF
};
const uint8_t gameoverscreen_imgsteam[] PROGMEM = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFD, 0xFF, 0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFE, 0x7F, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x3F, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x9F, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xDF, 0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xBF, 0xFF, 0xDF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x3F, 0xFF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x7F, 0xFF, 0x9F, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFE, 0x7F, 0xFF, 0xBF, 0xFB, 0xFF, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFC, 0xFF, 0xDF, 0xBF, 0xFB, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xF9, 0xFF, 0xFC, 0x00, 0x1F, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xF3, 0xFF, 0x81, 0x00, 0x00, 0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0x7F, 0xF7, 0xFF, 0xC3, 0x00, 0x04, 0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xEF, 0xFF, 0x46, 0x00, 0x04, 0x7F, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xEF, 0xFF, 0x04, 0x00, 0x04, 0x00, 0x67, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xEF, 0xFF, 0x04, 0x00, 0x04, 0x00, 0x77, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xEF, 0xF8, 0x04, 0x00, 0x06, 0x00, 0x17, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xEF, 0xE8, 0x04, 0x00, 0x03, 0x00, 0x13, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xE8, 0x04, 0x00, 0x01, 0x00, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xC8, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF9, 0xF0, 0x0C, 0x00, 0x06, 0x00, 0x01, 0x00, 0x04, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFD, 0xF0, 0x04, 0x00, 0x02, 0x00, 0x03, 0x00, 0x05, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFD, 0x00, 0x02, 0x00, 0x03, 0x00, 0x02, 0x00, 0x05, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF2, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06, 0x00, 0x05, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF3, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x0D, 0x7F, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE1, 0xE0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE1, 0xE0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE0, 0xE0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x47, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0xF0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0xF0, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x3B, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x9E, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x9E, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF1, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF7, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x04, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x1F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x06, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x10, 0x00, 0x00, 0x00, 0x03, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x18, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x08, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x08, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x04, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x04, 0x00, 0x00, 0x03, 0x3F, 0xFF, 0xF8, 0x00, 0x00, 0x44, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xE1, 0x9F, 0xF8, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x10, 0x00, 0x03, 0x3F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x10, 0x00, 0x03, 0x3F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF
};
const uint8_t winscreen_img[] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0x80, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x70, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFF, 0xF3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x07, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0xC0, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x01, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x80, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x01, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x80, 0x1D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x80, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDC, 0x01, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xC0, 0x39, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0x01, 0xE0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x60, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x03, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x30, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x07, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x0F, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0C, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x1E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x7C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0xC0, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x03, 0xE0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x78, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x1F, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1E, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x7E, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x07, 0x8F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xF8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xE0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0xFF, 0xFF, 0xCD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x78, 0xFF, 0xFF, 0x0E, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xF0, 0x3F, 0xFE, 0x07, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF8, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xF6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xE0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7B, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xE8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7B, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xF8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x02, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00
};


//game difficulty parameters
const uint8_t NUMCARS = 2; //number of cars to win the game
const uint8_t DELAYSTEP = 2; //number of cars before delay decrements
const uint16_t CAR_LAUNCHDELAYMAX_MS = 2000; //starting / reset delay values
const uint8_t CAR_MOVEDELAYMAX_MS = 100;
const uint8_t CARLAUNCH_DECR = 250; //decrement amounts
const uint8_t CARMOVE_DECR = 25;
//note: <30 move delay significant jump in difficulty

//global variables for game
const uint8_t ROAD_W = 88; //road width, closest to viewer
const uint8_t ROAD_H = 30; //2d height of road
const uint8_t ROAD_DEL = 30; //for parallax, degree of road lines converging

const uint8_t ROAD_CEN = display.width()/2; //centre point of road
const uint8_t ROAD_L_EDGE = ROAD_CEN - ROAD_W /2; //left edge, closest to viewer
const uint8_t ROAD_R_EDGE = ROAD_CEN + ROAD_W /2;
const uint8_t ROAD_Y = display.height() - ROAD_H; //y pixel position of road line = 34

const uint8_t CAR_H = 8;
const uint8_t CAR_W = 16;
const uint8_t CAR_Y = 55;

enum sideOfRoad {left_side, down_centre, right_side, both_sides, left_cen, right_cen}; //type definitions: add left_cen, right_cen
enum gameReturn {none, collision, win};
enum State {S_Start, S_Load, S_Running, S_Paused, S_Winning, S_Gameover};
State current_state = S_Start;
uint32_t gameStartTime_ms = 0;
uint32_t gameTime_ms = 0;
float potAvg = 0; float potOld = 0;
bool canLoad = false;

//global variables for buttons
uint8_t startButtonPin = 11;
uint8_t pauseButtonPin = 12;
const uint8_t DEBOUNCE_DELAY_MS = 200;
volatile bool start_pressed = 0;
volatile bool pause_pressed = 0;

//CAR FUNCTIONS
sideOfRoad getRandomSide(){
  sideOfRoad values[6] = {left_side, down_centre, right_side, both_sides, left_cen, right_cen};
  uint8_t r = (uint8_t)random(0,6);
  return values[r];
}
void drawRoad(uint8_t med){
  display.drawLine(ROAD_L_EDGE+ROAD_DEL, ROAD_Y, ROAD_L_EDGE, ROAD_Y+ROAD_H, WHITE); // draw road edges
  display.drawLine(ROAD_R_EDGE-ROAD_DEL, ROAD_Y, ROAD_R_EDGE, ROAD_Y+ROAD_H, WHITE);
  //alternate median strip lines
  //for loop used as initially much smaller spacing (i increment)
  if (med==0){
    for (uint8_t i = 0; i<ROAD_H; i=i+20){
    display.drawFastVLine(ROAD_CEN, ROAD_Y+i, 5, WHITE);}
  }
  else if(med==1){
    for (uint8_t i = 5; i<ROAD_H; i=i+20){
    display.drawFastVLine(ROAD_CEN, ROAD_Y+i, 5, WHITE);}
  }
  else if(med==2){
    for (uint8_t i = 10; i<ROAD_H; i=i+20){
    display.drawFastVLine(ROAD_CEN, ROAD_Y+i, 5, WHITE);}
  }
  else{
    for (uint8_t i = 15; i<ROAD_H; i=i+20){
    display.drawFastVLine(ROAD_CEN, ROAD_Y+i, 5, WHITE);}
  }
}
void drawCar(int cen){
  //display.drawRect(cen-(CAR_W/2), CAR_Y, CAR_W, CAR_H, WHITE); //draw car from top L corner position
  display.drawBitmap(cen-(CAR_W/2), CAR_Y, car_img, CAR_W, CAR_H, WHITE);
}
bool collisionDetectionRoad(uint8_t car_cen){
  //update to include collision detection w cars at proximity 30
  if ((car_cen - CAR_W/2)< ROAD_L_EDGE){
    return true;
  }
  else if ((car_cen + CAR_W/2)>ROAD_R_EDGE){
    return true;
  }
  else {
    return false;
  }
}
bool collisionDetectionCar (uint8_t car_cen, sideOfRoad side){
  switch(side){
    case left_side: 
      if((car_cen - CAR_W/2) < (ROAD_CEN - ROAD_W/4 + CAR_W/2)){return true;}
      else {return false;}

    case right_side:
      if((car_cen + CAR_W/2) > (ROAD_CEN + ROAD_W/4 - CAR_W/2)){return true;}
      else {return false;}

    case both_sides:
      if((car_cen - CAR_W/2) < (ROAD_CEN - ROAD_W/4 + CAR_W/2)){return true;} //collide with left car
      else if((car_cen + CAR_W/2) > (ROAD_CEN + ROAD_W/4 - CAR_W/2)){return true;} //collide with right car
      else {return false;}

    case down_centre:
      if((car_cen < ROAD_CEN) and ((car_cen + CAR_W/2) > (ROAD_CEN - CAR_W/2))){return true;}
      if((car_cen > ROAD_CEN) and ((car_cen - CAR_W/2) < (ROAD_CEN + CAR_W/2))){return true;}
      //on left side of road, right edge of car > left edge of centre car
      //on right side of road, left edge of car < right edge of centre car
      else {return false;}
    
    case left_cen:
      if((car_cen - CAR_W/2) < ROAD_CEN + CAR_W/2) {return true;} //left edge of car < right edge of centre car
      else {return false;}

    case right_cen:
      if ((car_cen + CAR_W/2) > ROAD_CEN - CAR_W/2) {return true;} //right edge of car > left edge of centre car
      else {return false;}
  }
  return false;
}
void carApproaching(int car_prox, sideOfRoad side){
  //car gets bigger during vertical travel (x/30)
  float car_scaling = (float)car_prox / (float)ROAD_H; 
  float car_scaling_size = min(car_scaling*10, 1.0);

  // int car_scaling_pos_right = map(car_prox,0,ROAD_H,ROAD_CEN + 0.5*ROAD_W - 0.75*ROAD_DEL, ROAD_CEN + 0.25*ROAD_W);
  // int car_scaling_pos_right = ROAD_CEN + 7 + car_prox/2 [i.e +7 to +22] <- line of road
  int car_scaling_pos_right = map(car_prox,0,ROAD_H,ROAD_CEN+10, ROAD_CEN+25); //is hard coded
  int car_scaling_pos_left = map(car_prox,0,ROAD_H,ROAD_CEN-10, ROAD_CEN-25);

  switch (side){
    case left_side: //car moving down left
      //display.drawRect(car_scaling_pos_left-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_left-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    case down_centre: //car moving down centre
      //display.drawRect(ROAD_CEN-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(ROAD_CEN-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    case right_side: //car moving down right
      //display.drawRect(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    case both_sides:
      //display.drawRect(car_scaling_pos_left-(CAR_W/2*car_scaling_size),ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      //display.drawRect(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_left-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE); 
      break;

    case left_cen:
      //display.drawRect(car_scaling_pos_left-(CAR_W/2*car_scaling_size),ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      //display.drawRect(ROAD_CEN-(CAR_W/2*car_scaling_size),ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_left-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(ROAD_CEN-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    case right_cen:
      //display.drawRect(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      //display.drawRect(ROAD_CEN-(CAR_W/2*car_scaling_size),ROAD_Y+car_prox, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(car_scaling_pos_right-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      display.drawBitmap(ROAD_CEN-(CAR_W/2*car_scaling_size), ROAD_Y+car_prox, car_img, CAR_W*car_scaling_size, CAR_H*car_scaling_size, WHITE);
      break;

    //case car changing lanes? -> fixed final position to check for collision
  }  
}

//DISPLAY FUNCTIONS
void displayStartScreen(bool startscreenstate){
  display.clearDisplay();
  if (startscreenstate){
    display.drawBitmap(0,0,startscreen_img,display.width(),display.height(),WHITE);
    display.setTextSize(1);                 
    display.setCursor(32,30);
    display.setTextColor(WHITE);             
    display.println(F("press start"));
  }else{
    display.drawBitmap(0,0,startscreen_img,display.width(),display.height(),WHITE);
  }
  display.display();
}
bool displayLoadScreen(){
  display.clearDisplay();
  display.setTextSize(1);                 
  display.setCursor(0,0);             
  display.println(F("Please calibrate steering wheel"));
  uint32_t potValue = analogRead(A0); //read potentiometer value
  potAvg = 0.1*potValue + 0.9*potOld;
  potOld = potAvg;
  uint32_t posValue = map(potAvg,1,1023,ROAD_L_EDGE, ROAD_R_EDGE); //map to car centre position
  display.drawFastVLine(posValue,32,5,WHITE);
  display.drawFastVLine(ROAD_L_EDGE,32,5,WHITE);
  display.drawFastVLine(ROAD_R_EDGE,32,5,WHITE);
  display.display();
  //return to 'canLoad' boolean
  if(collisionDetectionRoad(posValue)){
    return false;
  }else{
    return true;
  }
}
void displayPause(){
  display.setTextSize(2);                  
  display.setCursor(28,10);             
  display.println(F("PAUSED"));
  display.display();
}
void displayBOOM(){
  display.setTextSize(2);                  
  display.setCursor(0,0);             
  display.println(F("*^KABOOMv#"));
  display.display();
}
void displaygameover(bool endscreenstate){
  display.clearDisplay();
  if(endscreenstate){
    display.drawBitmap(0,0,gameoverscreen_img, display.width(),display.height(), WHITE);
  }else{
    display.drawBitmap(0,0,gameoverscreen_imgsteam, display.width(), display.height(), WHITE);
  }
  display.setTextSize(1);                  
  display.setCursor(10,2);
  display.setTextColor(BLACK);          
  display.println(F("Press start to try"));
  display.setCursor(90,12);
  display.println(F("again."));
  display.display();
}
void displayWOO(){
  display.clearDisplay();
  display.drawBitmap(0,0,winscreen_img,display.width(),display.height(),WHITE);
  display.setTextSize(1);                    
  display.setCursor(44,10);  
  display.setTextColor(BLACK);           
  display.println(F("WINNING"));
  testanimate(logo_bmp, LOGO_WIDTH, LOGO_HEIGHT);
  display.display();
}
void displayCarsRemaining(uint8_t num, uint8_t count){
  display.setTextSize(1);               
  display.setCursor(0,0);             
  display.print(F("Cars remaining: "));
  display.print(num - count);
}

//THE GAME
gameReturn runGame(){
  static uint16_t carLaunchDelay_ms = CAR_LAUNCHDELAYMAX_MS; //<- minimum time before next car launches (decreases)
  static uint8_t carMoveDelay_ms = CAR_MOVEDELAYMAX_MS; //<-- delay affects speed of car (decreases)

  static uint8_t car_prox = 0; //increases as cars move toward screen 0->30 (road_h)
  static uint32_t lastCar_ms = 0;
  static uint32_t lastCarMove_ms = 0;
  static bool launchCar = false;
  static sideOfRoad nextCarSide = getRandomSide();
  static uint8_t car_count = 0;

  static uint8_t medianState = 0;
  static uint32_t lastMedianChange_ms = 0;

  //reset game variables for re-start of game
  if (gameTime_ms == 0){
    car_prox = 0; lastCar_ms = 0; launchCar = false; lastCarMove_ms = 0;
    car_count = 0; carLaunchDelay_ms = CAR_LAUNCHDELAYMAX_MS; carMoveDelay_ms = CAR_MOVEDELAYMAX_MS;
    lastMedianChange_ms = 0; medianState = 0;
  }
  //calculate position of user's car
  uint32_t potValue = analogRead(A0); //read potentiometer value
  potAvg = 0.1*potValue + 0.9*potOld; //implement rolling average
  potOld = potAvg;
  uint32_t posValue = map(potAvg,1,1023,ROAD_L_EDGE, ROAD_R_EDGE); //map to car centre position
  
  display.clearDisplay();
  drawRoad(medianState);
  drawCar(posValue);

  //determine if median strip needs to be alternated
  if ((gameTime_ms - lastMedianChange_ms) > 250){
    lastMedianChange_ms = gameTime_ms;
    if(medianState==0){medianState=1;}
    else if(medianState==1){medianState=2;}
    else if(medianState==2){medianState=3;}
    else{medianState=0;}
  }
  
  //launch a car depending if carLaunchDelay_ms threshold reached
  if ((gameTime_ms - lastCar_ms) > carLaunchDelay_ms){
    lastCar_ms = gameTime_ms;
    launchCar = true;
  }
  //draw the approaching cars, incrementing downwards depending on carMoveDelay_ms
  if (launchCar){
      carApproaching(car_prox,nextCarSide); //car approaching of distance away, and position designator
      if (millis() - lastCarMove_ms > carMoveDelay_ms){ //carMoveDelay determines speed of car approach 50 -> 0.
        lastCarMove_ms = millis();
        car_prox = car_prox + 1; //car proximity 0 (top of road) to road height (bottom of screen)
      } 
      //when car reaches end of road...    
      if(car_prox > ROAD_H){
        car_prox = 0; //reset car distance
        launchCar = false; //car no longer on road
        car_count++; //increment cars passed
        nextCarSide = getRandomSide(); //for next car

        //win if count > threshold. alternatively, game time could correspond to distance travelled.
        if (car_count == NUMCARS){ return win;}

        //decrease car delays evey delayStep # cars
        if ((car_count > 0) and (car_count % DELAYSTEP) == 0){
          carLaunchDelay_ms = max(carLaunchDelay_ms - CARLAUNCH_DECR,0);
          carMoveDelay_ms = max(carMoveDelay_ms - CARMOVE_DECR,0);
        }
      }
  }
    
  //check for collisions with road & approaching cars (allowing for "clipping" if passed)
  if (collisionDetectionRoad(posValue)){return collision;}
  if((car_prox > ROAD_H-10) and (car_prox < ROAD_H-5) and (collisionDetectionCar(posValue,nextCarSide))){
    return collision;
  }
  displayCarsRemaining(NUMCARS, car_count);
  display.display(); //display buffer contents to screen
  gameTime_ms = millis() - gameStartTime_ms; //update game timer
  return none; //= game continues
}

//MAIN- STATE MACHINE
void setup() {
  Serial.begin(9600);
  Wire.setClock(3400000);

  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3C for 128x32
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }
  pinMode(startButtonPin, INPUT_PULLUP);
  pinMode(pauseButtonPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(startButtonPin), ISR_Start, FALLING);
  attachInterrupt(digitalPinToInterrupt(pauseButtonPin), ISR_Pause, FALLING);

  display.setTextColor(WHITE);  //as constant
  display.display(); //initial buffer = Adafruit splash screen
  display.clearDisplay();   // Clear the buffer
  delay(1000);
}

void loop() {
  static uint32_t startscreentime_ms = 0;  static uint32_t gameovertime_ms = 0;  static uint32_t endscreentime_ms = 0;
  static bool startscreenstate = 0;  static bool endscreenstate = 0;
  switch (current_state){

    case S_Start:
      //start screen alternates displaying "press start" text
      displayStartScreen(startscreenstate);
      if ((millis() - startscreentime_ms) > 1000){
        startscreentime_ms = millis();
        startscreenstate = !startscreenstate;
      }
      if (start_pressed){
        current_state = S_Load;
        start_pressed = 0;
      }
      break;

    case S_Load:
      //load screen to calibrate steering wheel (potentiometer)
      //displayLoadScreen() returns false if would result in crash (with road edge) on game start
      canLoad = displayLoadScreen();
      if (start_pressed and canLoad){
        current_state = S_Running;
        gameStartTime_ms = millis(); //time when start button was pressed
        gameTime_ms = 0; //reset game time
        start_pressed = 0;
        pause_pressed = 0; //in case it was latched (which resulted in pausing the load screen)
      } else{
        start_pressed = 0;
      }
      break;

    case S_Running:
      //could have "startofGame()" = countdown + driving past chequered start line
      //run game until win or gameover
      if (start_pressed){
        start_pressed = 0; //prevents skipping gameover / win screen
      }
      if (pause_pressed){
        current_state = S_Paused; //pauses game
        pause_pressed = 0;
      }else{ //moves out of 'game running' state in collision / win events
          gameReturn g = runGame();
          if (g == collision){
            current_state = S_Gameover;
            gameovertime_ms = millis();
          }
          else if(g == win){current_state = S_Winning;}
      }
      break;

    case S_Paused:
      //display "pause" text, keeping current frame on screen
      displayPause();
      if (pause_pressed){
        current_state = S_Running;
        pause_pressed = 0;
      }
      break;

    case S_Winning:
      //alternating win screen
      displayWOO();
      if(start_pressed){
        display.clearDisplay();
        current_state = S_Start;
        start_pressed = 0;
        startscreenstate = 0; endscreenstate = 0; //for screen display consistency
        snowflakeinit = 0; //^
      }
      break;

    case S_Gameover:
      //display "boom" text if crash
      //alternating gameover screen
      if ((millis() - gameovertime_ms) < 1000){
        displayBOOM();
      }else{
        displaygameover(endscreenstate);
      }
      if ((millis() - endscreentime_ms) > 1000){
        endscreentime_ms = millis();
        endscreenstate = !endscreenstate;
      }
      if(start_pressed){
        display.clearDisplay();
        current_state = S_Start;
        start_pressed = 0;
        startscreenstate = 0; endscreenstate = 0;
      }
      break;
  }
}

void ISR_Start(){
  static uint32_t laststartpress_ms = 0;
  if ((millis() - laststartpress_ms) > DEBOUNCE_DELAY_MS){
    laststartpress_ms = millis();
    start_pressed = 1;
  }
}
void ISR_Pause(){
  static uint32_t lastpausepress_ms = 0;
  if (millis() - lastpausepress_ms > DEBOUNCE_DELAY_MS){
    lastpausepress_ms = millis();
    pause_pressed = 1;
  }
}
/*** COMMENTS ***********/
//128x64 pixels -> 30..98, 
//potValue rolling average?

//car = bit map
//collision with road state
//collision with approaching car
// queue cars using timers

//how to draw curved road?
//track / display time, metres left, fps

//exten: joystick: degree of acceleration, braking, steering
// speed control is level of agency on top of steering / handling.
//add more difficult courses (tight corners) where reckless acceleration is punished

//consideration of variable screen sizes -> distances relative to edge, proportional to total dimension


/** DRAWING FUNCTIONS *****/
/*
void testdrawline() {
  int16_t i;

  display.clearDisplay(); // Clear display buffer

  for(i=0; i<display.width(); i+=4) {
    display.drawLine(0, 0, i, display.height()-1, WHITE);
    display.display(); // Update screen with each newly-drawn line
    delay(1);
  }
  for(i=0; i<display.height(); i+=4) {
    display.drawLine(0, 0, display.width()-1, i, WHITE);
    display.display();
    delay(1);
  }
  delay(250);

  display.clearDisplay();

  for(i=0; i<display.width(); i+=4) {
    display.drawLine(0, display.height()-1, i, 0, WHITE);
    display.display();
    delay(1);
  }
  for(i=display.height()-1; i>=0; i-=4) {
    display.drawLine(0, display.height()-1, display.width()-1, i, WHITE);
    display.display();
    delay(1);
  }
  delay(250);

  display.clearDisplay();

  for(i=display.width()-1; i>=0; i-=4) {
    display.drawLine(display.width()-1, display.height()-1, i, 0, WHITE);
    display.display();
    delay(1);
  }
  for(i=display.height()-1; i>=0; i-=4) {
    display.drawLine(display.width()-1, display.height()-1, 0, i, WHITE);
    display.display();
    delay(1);
  }
  delay(250);

  display.clearDisplay();

  for(i=0; i<display.height(); i+=4) {
    display.drawLine(display.width()-1, 0, 0, i, WHITE);
    display.display();
    delay(1);
  }
  for(i=0; i<display.width(); i+=4) {
    display.drawLine(display.width()-1, 0, i, display.height()-1, WHITE);
    display.display();
    delay(1);
  }

  delay(2000); // Pause for 2 seconds
}

void testdrawrect(void) {
  display.clearDisplay();

  for(int16_t i=0; i<display.height()/2; i+=2) {
    display.drawRect(i, i, display.width()-2*i, display.height()-2*i, WHITE);
    display.display(); // Update screen with each newly-drawn rectangle
    delay(1);
  }

  delay(2000);
}

void testfillrect(void) {
  display.clearDisplay();

  for(int16_t i=0; i<display.height()/2; i+=3) {
    // The INVERSE color is used so rectangles alternate white/black
    display.fillRect(i, i, display.width()-i*2, display.height()-i*2, INVERSE);
    display.display(); // Update screen with each newly-drawn rectangle
    delay(1);
  }

  delay(2000);
}

void testdrawcircle(void) {
  display.clearDisplay();

  for(int16_t i=0; i<max(display.width(),display.height())/2; i+=2) {
    display.drawCircle(display.width()/2, display.height()/2, i, WHITE);
    display.display();
    delay(1);
  }

  delay(2000);
}

void testfillcircle(void) {
  display.clearDisplay();

  for(int16_t i=max(display.width(),display.height())/2; i>0; i-=3) {
    // The INVERSE color is used so circles alternate white/black
    display.fillCircle(display.width() / 2, display.height() / 2, i, INVERSE);
    display.display(); // Update screen with each newly-drawn circle
    delay(1);
  }

  delay(2000);
}

void testdrawroundrect(void) {
  display.clearDisplay();

  for(int16_t i=0; i<display.height()/2-2; i+=2) {
    display.drawRoundRect(i, i, display.width()-2*i, display.height()-2*i,
      display.height()/4, WHITE);
    display.display();
    delay(1);
  }

  delay(2000);
}

void testfillroundrect(void) {
  display.clearDisplay();

  for(int16_t i=0; i<display.height()/2-2; i+=2) {
    // The INVERSE color is used so round-rects alternate white/black
    display.fillRoundRect(i, i, display.width()-2*i, display.height()-2*i,
      display.height()/4, INVERSE);
    display.display();
    delay(1);
  }

  delay(2000);
}

void testdrawtriangle(void) {
  display.clearDisplay();

  for(int16_t i=0; i<max(display.width(),display.height())/2; i+=5) {
    display.drawTriangle(
      display.width()/2  , display.height()/2-i,
      display.width()/2-i, display.height()/2+i,
      display.width()/2+i, display.height()/2+i, WHITE);
    display.display();
    delay(1);
  }

  delay(2000);
}

void testfilltriangle(void) {
  display.clearDisplay();

  for(int16_t i=max(display.width(),display.height())/2; i>0; i-=5) {
    // The INVERSE color is used so triangles alternate white/black
    display.fillTriangle(
      display.width()/2  , display.height()/2-i,
      display.width()/2-i, display.height()/2+i,
      display.width()/2+i, display.height()/2+i, INVERSE);
    display.display();
    delay(1);
  }

  delay(2000);
}

void testdrawchar(void) {
  display.clearDisplay();

  display.setTextSize(1);      // Normal 1:1 pixel scale
  display.setTextColor(WHITE); // Draw white text
  display.setCursor(0, 0);     // Start at top-left corner
  display.cp437(true);         // Use full 256 char 'Code Page 437' font

  // Not all the characters will fit on the display. This is normal.
  // Library will draw what it can and the rest will be clipped.
  for(int16_t i=0; i<256; i++) {
    if(i == '\n') display.write(' ');
    else          display.write(i);
  }

  display.display();
  delay(2000);
}

void testdrawstyles(void) {
  display.clearDisplay();

  display.setTextSize(1);             // Normal 1:1 pixel scale
  display.setTextColor(WHITE);        // Draw white text
  display.setCursor(0,0);             // Start at top-left corner
  display.println(F("Hello, world!"));

  display.setTextColor(BLACK, WHITE); // Draw 'inverse' text
  display.println(3.141592);

  display.setTextSize(2);             // Draw 2X-scale text
  display.setTextColor(WHITE);
  display.print(F("0x")); display.println(0xDEADBEEF, HEX);

  display.display();
  delay(2000);
}

void testscrolltext(void) {
  display.clearDisplay();

  display.setTextSize(2); // Draw 2X-scale text
  display.setTextColor(WHITE);
  display.setCursor(10, 0);
  display.println(F("scroll"));
  display.display();      // Show initial text
  delay(100);

  // Scroll in various directions, pausing in-between:
  display.startscrollright(0x00, 0x0F);
  delay(2000);
  display.stopscroll();
  delay(1000);
  display.startscrollleft(0x00, 0x0F);
  delay(2000);
  display.stopscroll();
  delay(1000);
  display.startscrolldiagright(0x00, 0x07);
  delay(2000);
  display.startscrolldiagleft(0x00, 0x07);
  delay(2000);
  display.stopscroll();
  delay(1000);
}

void testdrawbitmap(void) {
  display.clearDisplay();

  display.drawBitmap(
    (display.width()  - LOGO_WIDTH ) / 2,
    (display.height() - LOGO_HEIGHT) / 2,
    logo_bmp, LOGO_WIDTH, LOGO_HEIGHT, 1);
  display.display();
  delay(1000);
}
*/

void testanimate(const uint8_t *bitmap, uint8_t w, uint8_t h) {
  static int8_t f, icons[NUMFLAKES][3];
  // Initialize 'snowflake' positions
  if(!snowflakeinit){
    for(f=0; f< NUMFLAKES; f++) {
      icons[f][XPOS]   = random(1 - LOGO_WIDTH, display.width());
      icons[f][YPOS]   = -LOGO_HEIGHT;
      icons[f][DELTAY] = random(1, 6);
      //Serial.print(F("x: "));
      //Serial.print(icons[f][XPOS], DEC);
      //Serial.print(F(" y: "));
      //Serial.print(icons[f][YPOS], DEC);
      //Serial.print(F(" dy: "));
      //Serial.println(icons[f][DELTAY], DEC);
    }
    snowflakeinit = 1;
  }

  // Draw each snowflake:
  for(f=0; f< NUMFLAKES; f++) {
    display.drawBitmap(icons[f][XPOS], icons[f][YPOS], bitmap, w, h, WHITE);
  }
  // Then update coordinates of each flake...
  for(f=0; f< NUMFLAKES; f++) {
    icons[f][YPOS] += icons[f][DELTAY];
    // If snowflake is off the bottom of the screen...
    if (icons[f][YPOS] >= display.height()) {
      // Reinitialize to a random position, just off the top
      icons[f][XPOS]   = random(1 - LOGO_WIDTH, display.width());
      icons[f][YPOS]   = -LOGO_HEIGHT;
      icons[f][DELTAY] = random(1, 6);
    }
  }
}


/** EXAMPLE FUNCTION CALLS****/
/*Call display() to display on screen
Can buffer multiple drawn objects */

  //Example draw commands:
  //display.drawPixel(10, 10, WHITE);     // Draw a single pixel in white
  //testdrawline();      // Draw many lines
  //testdrawrect();      // Draw rectangles (outlines)
  //testfillrect();      // Draw rectangles (filled)
  //testdrawcircle();    // Draw circles (outlines)
  //testfillcircle();    // Draw circles (filled)
  //testdrawroundrect(); // Draw rounded rectangles (outlines)
  //testfillroundrect(); // Draw rounded rectangles (filled)
  //testdrawtriangle();  // Draw triangles (outlines)
  //testfilltriangle();  // Draw triangles (filled)
  //testdrawchar();      // Draw characters of the default font
  //testdrawstyles();    // Draw 'stylized' characters
  //testscrolltext();    // Draw scrolling text
  //testdrawbitmap();    // Draw a small bitmap image

  // Invert and restore display, pausing in-between
  /*display.invertDisplay(true);
  delay(1000);
  display.invertDisplay(false);
  delay(1000); 
  */

  //testanimate(logo_bmp, LOGO_WIDTH, LOGO_HEIGHT); // Animate bitmaps